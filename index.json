[{"categories":["Docker"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"前言 在我这可以，在你那怎么就跑不起来了？ 在以前，项目开发完成后，测试/运维需要从头到尾搭建环境、调试。这样的话经常出现在开发的口中，不过，随着技术的不断发展，在容器技术诞生后，这个问题就可以轻松的解决了。容器技术就像一个打包工具，使我们可以以与管理应用程序相同的方式管理基础架构。部署操作都命令化，集中成一个脚本就可以完成原来复杂的部署过程。打包的不仅是你的程序，也包括运行的环境，因此消除了我们重复的、单调的配置/调试任务。项目在打包后可以在所有的环境下，以相同的方式运行。让开发测试等成员不再关注构建、调试等事情。可以将更多的时间放在业务本身。 docker 简介 不同于虚拟机，容器技术只隔离应用程序的运行环境但容器之间可以共用同一个操作系统，这使它在继承了虚拟机优点的同时还摒弃了其缺点。而 docker，则是容器技术的其中一种实现。 docker 是一个用 Go 语言实现的开源项目，可以让我们方便的创建和使用容器。 docker 使用客户端-服务器架构。客户端通过一些命令行与守护进程交互，守护进程管理 Docker 对象，如镜像、容器、网络和 volume。 docker 三要素 image：镜像，一个只读模版，其中包含创建 Dokcer 容器的说明。 container：容器，镜像的可运行实例。可以使用 docker cli 创建/启动/停止/删除/移动容器。同一个镜像，可以生成多个同时运行的容器。容器之间默认相互隔离。 repository：镜像仓库，存放了各种各样的 image，相当于代码仓库中的 github。 docker 的基本使用 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:0","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"根据镜像启动一个容器 # 前置 # 使用apt（或其他）下载docker apt install docker # 例 # 使用 run命令 启动一个容器 docker run \u003cimage name\u003e docker run ubuntu 当系统内没有 ubuntu 镜像时会自动去 docker hub 上拉取后再启动容器。默认attached模式，会占用当前窗口并展示实时日志。可以通过Ctrl + c停止 docker 服务。更适用于容器和程序的调试阶段。 如果想在后台运行可以（使用detached模式）docker run -d \u003c image name \u003e docker run -d ubuntu # 查看在后台运行的容器的日志 # docker logs \u003cname or id\u003e ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:1","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"查看已启动的容器 docker ps # 会打印当前运行的docker容器信息 # id 容器id # image 镜像名称 # status 状态 up/exited ... # ports 协议和端口 # names 容器名称 ... docker ps 只能查看运行的容器，如果要查看所有容器（包括已停止的）可以加个 -a参数:docker ps -a 只查看容器 id 可以加个-q参数：docker ps -q(可以搭配 docker rm 使用 进行批量删除实例： docker rm $(docker container ps -aq)) ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:2","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"停止/启动/重启/删除一个已启动的容器 docker stop \u003cname or id\u003e docker start \u003cname or id\u003e docker restart \u003cname or id\u003e docker rm \u003cname or id\u003e # 删除容器前需要先停止容器。或加上强制删除参数 -f ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:3","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"开启容器的交互 有时候容器不是一个简单的服务，而是需要交互的操作系统，可以在使用detached模式启动容器后使用 exec 进入容器进行交互 docker exec -it \u003cname or id\u003e sh # exec 执行 # -it 交互模式 # sh 使用shell脚本进行交互 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:4","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"其他 #image docker pull \u003cimage name\u003e # 在docker hub中拉取镜像 docker image ls #查看已有的镜像信息 docker image inspect \u003cimage id\u003e #查看镜像详细信息，例如镜像id，暴露出的端口，volumn位置等。 # 导出一个已有的镜像，执行后，当前文件夹下会生成一个镜像文件 # save：导出； # \u003cname:tag\u003e:镜像名称：版本； # -o: 输出 # fileName：导出后的文件名称 docker image save \u003cname:tag\u003e -o \u003cfileName\u003e # 导入一个已有的镜像 # \u003c./filename\u003e 要导入的镜像文件路径 docker image load -i \u003c./filename\u003e 使用 Dockerfile 构建自己的镜像 之前使用的是已创建好的镜像， 我们可以自定义一个 Dockerfile 文件来构建自己的镜像。一般我们会在应用程序根目录与 package.json 同级目录下创建 Dockerfile 文件。 Dockerfile 是一个文本文件，它包含了用户可以在命令行上调用的 docker 构建景象相关的所有命令，它遵循特定的格式和指令集，指令名称和参数以空格分隔，指令名称不区分大小写，但 Docker 约定它们是大写的，以便更容易的区分指令和参数。其他具体指令可以参考 Dockerfile 语法,每个语法指令都会在图像中创建一个图层，当您更改 Dockerfile 并重建映像时，只有那些已更改的图层才会被重建。这也是镜像相对小巧、快速的部分原因。 说几个常用的语法指令： ARG: 用来定义参数的命令,可以在打包镜像时使用docker build --build-arg \u003cvarname\u003e=\u003cvalue\u003e 命令将变量值传递到 Dockerfile 内部，如果 ARG 指令有默认值并且在构建时没有传递任何值，则构建器使用默认值。 # ARG \u003cname\u003e[=\u003cdefault value\u003e] ARG data ARG name=zhangsan ARG age=18 FORM: 在 Dockerfile 里，除去 ARG 指令外，一个有效的 Dockerfile 必须由 FROM 指令开头，用来指定你要构建镜像的基础镜像。FROM 指令前面只能有一个或多个 ARG 指令，用来声明 FROM 行使用的参数。 WORKDIR：用来定义镜像运行后的工作目录 COPY: 用来将主机的文件复制到镜像中，. . 表示将当前目录复制到容器中。 CMD：打包好的镜像在启动后默认执行的命令。 ESPOSE：用来暴露镜像的端口号，告知使用容器的人，当前镜像需要监听的的端口和协议。暴露出来后，可以在镜像打包后，通过 docker inspect \u003cimage id\u003e 来查看暴露出的端口。 # cd /app # vi Dockerfile FROM node:18-alpine WORKDIR /app COPY . . CMD [\"node\", \"src/index.js\"] EXPOSE 3000 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:5","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"使用docker build根据Dockerfile构建镜像 # 根据Dockerfile构建镜像 # build 构建命令 # -t \u003cimage name\u003e通过-t给要打包的镜像取一个名字 # path Dockerfile文件所在路径 # docker build -t \u003cimage name\u003e \u003cpath:相对路径，根据这个路径寻找Dockerfile文件\u003e .表示它应该在当前目录中查找Dockerfile。 # 例 docker build -t tzzimage . # 路径是必填项 . 指的是当前路径 打包完成后，docker image ls查看已有镜像发现 tzzimage 镜像已经存在了。 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:6","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"运行构建好的镜像 # -d 从后台启动容器 # -p port:port: 指定端口映射，第一个port表示主机要发布的端口，第二个是容器暴露的端口。没有端口映射将无法访问在容器中启动的应用程序。 docker run -dp 3000:3000 tzzimage 执行后，就可以访问 http://localhost:3000 了。 还可以通过docker ps查看容器状态 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:7","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"状态管理 启动后的容器是无状态的，虽然可以容器中创建、更新、删除文件，但随着容器的关闭，相关的数据并不会得到保留，但是在日常使用中，经常会遇到一些需要保留数据的容器，或者在多个容器之间进行数据共享。这就涉及到了容器的数据管理。需要对容器中的数据进行持久化。 Volume volume 提供了将容器特定文件到主机的能力，如果在容器启动时挂载容器中的目录，则该目录的更改也会在主机上看到。我们跨容器重新启动并挂载同一目录，我们会看到相同的文件。 使用docker volume create命令创建卷。 docker volume create volume1 执行 docker run 命令时添加–mount 选项指定 volumn 挂载， docker run -dp 3000:3000 --mount type=volume,src=volume1,target=/app tzzimage # or docker run -dp 3000:3000 -v volume1:/app tzzimage 表示我们使用了 volume1 volume，并将其挂载到了容器内的/app 目录下，如果该 volume 未被创建时，docker 会自动帮我们创建 在容器启动后，我们在/app 目录下创建一个文件 aaa.txt. 把容器删除后重新指定 volume 创建，会发现 aaa.txt 依旧存在。 通过 docker volume inspect 命令来查看 volume 详情, Mountpoint 属性，是主机磁盘存储数据的实际位置。docker 会把数据存储在这个地方，当我们使用这个 volume 启动容器的时候会把这个目录挂载到容器中 docker volume inspect todo-db [ { \"CreatedAt\": \"2023-02-22T09:23:11Z\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/volume1/_data\", \"Name\": \"volume1\", \"Options\": {}, \"Scope\": \"local\" } ] 通过这种方式，我们可以持久性的存储应用程序的数据，但在某些情况下，还有另外一种类型的状态管理。 bind bind 是另一种挂载方式，他允许你将主机文件系统的目录共享到容器中。在处理应用程序时，您可以使用 bind 方式，将程序源代码挂载到容器中。一旦在容器外部保存文件，容器内就会立即看到您对代码所做的更改。这意味着我们可以在容器中运行进程，监视文件系统更改并响应它们。我们可以搭配着 nodemon，对已启动的程序进行热更新。常常在本地开发调试的时候使用。 docker run -dp 3000:3000 --mount type=bind,src=/app,target=/app tzzimage ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:8","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第 2 天，点击查看活动详情 ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:0:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"前言 之前大致说了下 useRequest hook 的基本功能的实现。但 useRequest 的强大不止于此。它还支持如 loading 状态延时、请求防抖、节流、依赖刷新等功能。不过其实现方式都是通过内置的插件 hook 来进行实现的。这样做既可以保证核心代码的简洁，还能更方便的扩展出更高级的功能。并且还支持用户进行自定义插件。 ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:1:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"正文 ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"如何定义一个插件 可以通过插件 hook 的 ts 定义，看一下怎么定义一个插件： 插件 hook 接收两个参数， fetchInstance: fetch 实例； fetchOptions: useRequest 接收的 options； 支持返回一些回调函数： onBefore： 在请求接口前调用； onRequest： 在请求接口时调用； onSuccess： 在请求接口成功后调用； onError： 在请求接口失败后调用； onFinally： 在请求接口完成后调用； onCancel： 在请求接口取消后调用； onMutate： 在出发 mutate 函数时调用； 插件 hook 可以返回一系列的生命周期函数，使我们可以在接口请求的任意一个时机对 fetchInstance 进行处理。 插件 hook 还支持挂载一个静态方法 onInit()，在 Fetch 创建之前，可以通过 Init 方法进行一些前提处理。得到初始的 state。 const use***plugin = ( fetchInstance, fetchOptions, ) =\u003e { const onBefore = () =\u003e { // 对fetchInstance的状态的处理... } ... return { onBefore, ... } } use***plugin.onInit = (fetchOptions) =\u003e { ... } export default use***plugin ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:1","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"插件的使用 插件 hook 一般用来处理 Fetch 实例的状态，在 Fetch 实例被创建之前，会先执行所有插件可能存在的 onInit 方法，该方法会返回 initData，用来初始化 Fetch 实例。 在 Fetch 实例被初始化后，执行所有的插件 hooks，此时，会得到一个包含（onBrfore、onSuccess…）的数组。并将这些方法挂载到 fetchInstance 上。方便在各个时机使用。 const useRequestImplement = ( service: Promise\u003cany\u003e, options, plugins: Array\u003cPlugin\u003e ) =\u003e { // const { manual = false, ...rest } = options; // const fetchOptions = { // manual, // ...rest, // }; // const serviceRef = useLatest(service); // const update = useUpdate(); const fetchInstance = useCreation(() =\u003e { // 在Filter方法中的Boolean可以当成一个转换函数，用来筛选掉空的initData。 const initState = plugins .map((p) =\u003e p?.onInit?.(fetchOptions)) .filter(Boolean); // 将初始化的initState传给构造函数Fetch。 return new Fetch( serviceRef, fetchOptions, update, Object.assign({}, ...initState) ); }, []); // fetchInstance.options = fetchOptions; // 执行所有插件hook，并将其挂载到fetchInstance上。 fetchInstance.pluginImpls = plugins.map((p) =\u003e p(fetchInstance, fetchOptions) ); // useMount(() =\u003e { // // useCachePlugin can set fetchInstance.state.params from cache when init // const params = fetchInstance.state.params ?? []; // // @ts-ignore // fetchInstance.runAsync(...params); // }); // useUnmount(() =\u003e { // fetchInstance.cancel(); // }); // return { // loading: fetchInstance.state.loading, // data: fetchInstance.state.data, // error: fetchInstance.state.error, // params: fetchInstance.state.params || [], // cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)), // }; }; export default class Fetch\u003cTData, TParams extends any[]\u003e { // public count: number = 0; // // public state = { // loading: false, // params: undefined, // data: undefined, // error: undefined, // }; public pluginImpls: Array\u003cPluginReturn\u003e constructor( public serviceRef, public options, public subscribe, public initState ) { this.state = { ...this.state, loading: !options.manual, ...initState, //在constructor时会讲插件初始化生成的状态更新到state中。 }; } // setState(s) { // this.state = { // ...this.state, // ...s, // }; // this.subscribe(); // } // 插件处理函数，会批量执行某个生命周期的函数。并返回处理后的状态。 runPluginHandler(event: keyof PluginReturn, ...rest: any[]) { // @ts-ignore const r = this.pluginImpls.map((i) =\u003e i[event]?.(...rest)).filter(Boolean); return Object.assign({}, ...r); } // async runAsync(...params: TParams): Promise\u003cany\u003e { // this.count += 1; // const currentCount = this.count; // 执行所有插件hooks返回的‘onBefore’方法，并根据返回的state进行相应的处理 const { stopNow = false, returnNow = false, ...state } = this.runPluginHandler('onBefore', params); if (stopNow) { return new Promise(() =\u003e {}); } // // this.setState({ // loading: true, // params, ...state, // }); // // this.options.onBefore?.(params); // try { // const servicePromise = this.serviceRef.current(...params); // const res = await servicePromise; // if (currentCount !== this.count) { // return new Promise(() =\u003e {}); // } // this.setState({ // data: res, // error: undefined, // loading: false, // }); // // this.options.onSuccess?.(res, params); // this.options.onFinally?.(params, res, undefined); this.runPluginHandler('onSuccess', res, params); if (currentCount === this.count) { this.runPluginHandler('onFinally', params, res, undefined); } // // return res; // } catch (error) { // if (currentCount !== this.count) { // // prevent run.then when request is canceled // return new Promise(() =\u003e {}); // } // this.setState({ // error, // loading: false, // }); // // this.options.onError?.(error, params); // this.options.onFinally?.(params, undefined, error); this.runPluginHandler('onError', error, params); if (currentCount === this.count) { this.runPluginHandler('onFinally', params, undefined, error); } // throw error; // } // } // cancel() { // this.count += 1; // this.setState({ // loading: false, // }); this.runPluginHandler('onCancel'); // } // // refreshAsync() { // // @ts-ignore // return this.runAsync(...(this.state.params || [])); // } // run(...params: TParams) { // this.runAsync(...params).catch((error) =\u003e { // if (!this.options.onError) { // console.error(error); // } // }); // } // refresh() { //","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:2","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"Loading Delay useRequest 有个 loading delay 的功能，通过设置 options.loadingDelay ，可以延迟 loading 变成 true 的时间，有效防止闪烁。 这个内置 hook 插件用来控制 loading 状态的延迟。 const { loading, data } = useRequest(getUsername, { loadingDelay: 300 }); return \u003cdiv\u003e{ loading ? 'Loading...' : data }\u003c/div\u003e 例如上面的场景，假如 getUsername 在 300ms 内返回，则 loading 不会变成 true，避免了页面展示 Loading… 的情况。 我们可以尝试着通过插件 hook 的方式来实现一下。默认情况下，loading 状态在接口 onBefore 的时候会被更新成 true。那我们就需要在接口 onBefore 的时候，将其改为 false，并加一个定时器，让其在指定时间之后再变为 true： import { useRef } from 'react'; import type { Plugin, Timeout } from '../types'; const useLoadingDelayPlugin: Plugin\u003cany, any[]\u003e = (fetchInstance, { loadingDelay }) =\u003e { const timerRef = useRef\u003cTimeout\u003e(); // 用户没有设置loadingDelay时直接返回 if (!loadingDelay) { return {}; } // 取消定时器。 const cancelTimeout = () =\u003e { if (timerRef.current) { clearTimeout(timerRef.current); } }; return { // 更改loading的状态为false，并加个定时器，让其在指定的delay时间后在更正为true。 onBefore: () =\u003e { cancelTimeout(); timerRef.current = setTimeout(() =\u003e { fetchInstance.setState({ loading: true, }); }, loadingDelay); return { loading: false, }; }, // 在请求完成或取消时，记得销毁定时器。 onFinally: () =\u003e { cancelTimeout(); }, onCancel: () =\u003e { cancelTimeout(); }, }; }; export default useLoadingDelayPlugin; … ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:3","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"ready 和 refreshDeps useRequest 支持 ready 配置，当 options 中的 ready 值为 false 时，请求永远都不会发出。其具体行为如下： 当 manual=false 自动请求模式时，每次 ready 从 false 变为 true 时，都会自动发起请求，会带上参数 options.defaultParams。 当 manual=true 手动请求模式时，只要 ready=false，则通过 run/runAsync 触发的请求都不会执行。 支持依赖刷新，当 options 中的 refreshDeps 值变化后，会重新触发请求。 由于这两个需要类似，可以放在一个 hook 里实现 import { useRef } from 'react'; import useUpdateEffect from '../../../useUpdateEffect'; import type { Plugin } from '../types'; // support refreshDeps \u0026 ready const useAutoRunPlugin: Plugin\u003cany, any[]\u003e = ( fetchInstance, { manual, ready = true, defaultParams = [], refreshDeps = [], refreshDepsAction, } ) =\u003e { // 避免重复请求的ref。 const hasAutoRun = useRef(false); hasAutoRun.current = false; // 在自动模式（manual === false）且ready === true时发送请求。 useUpdateEffect(() =\u003e { if (!manual \u0026\u0026 ready) { hasAutoRun.current = true; fetchInstance.run(...defaultParams); } }, [ready]); // 在自动模式下，当refreshDeps发生变化，会出发refresh事件。 useUpdateEffect(() =\u003e { if (hasAutoRun.current) { return; } if (!manual) { hasAutoRun.current = true; fetchInstance.refresh(); } }, [...refreshDeps]); return { // 在请求前判断ready状态，等于true才能发送请求。 onBefore: () =\u003e { if (!ready) { return { stopNow: true, }; } }, }; }; // 还有一个onInit事件，初始化loading的状态，在自动模式且ready为true时状态才为true。 useAutoRunPlugin.onInit = ({ ready = true, manual }) =\u003e { return { loading: !manual \u0026\u0026 ready, }; }; export default useAutoRunPlugin; … 其他插件大同小异，可以前往 ahooks 仓库查看https://github.com/alibaba/hooks/tree/master/packages/hooks/src/useRequest/src/plugins end. ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:4","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第 1 天，点击查看活动详情 ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:0:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"前言 useRequest 是一个异步数据管理的 hooks，是 ahooks Hooks 库的核心 hook，因为其通过插件式组织代码，大部分功能都通过插件的形式来实现，所以其核心代码行数较少，简单易懂，还可以支持我们自定义扩展功能。可以说，useRequest 能处理 React 项目绝大多数的网络请求场景。 让咱自己写可能写不出来，那就先从模仿开始，通过阅读 useRequest 的代码，从中学习大佬们的代码逻辑和思维处理。 ahooks： https://ahooks.js.org/ 文中代码基于 3.7.2 版本 ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:1:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"前置 hook 了解 在 useRequest 的源码实现中使用到了一些其他的 hooks useCreation：useMemo 或 useRef 的替代品。 useLatest：返回当前最新值的 Hook， 可以避免闭包问题。 useMemoizedFn：useCallback 的替代品 。 useMount：只在组件初始化时执行的 Hook。 useUnmount：在组件卸载（unmount）时执行的 Hook。 useUpdate：强制组件重新渲染的 hook。 ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:2:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"实现最基础的 useRequest Hook const { data, error, loading, cancel } = useRequest(service); useRequest 通过定义一个 class 类 Fetch 来维护相关的数据（data，loading 等）和方法（run， refresh 等）然后在 useRequestImplement 中创建 Fetch 实例，并返回实例属性和方法。 我对代码进行了拆分，保留了 useRequest 中核心的功能，该 hook 接收一个 promise，需要返回 data、error、loading、cancel 状态。 const useRequestImplement = (service: Promise\u003cany\u003e) =\u003e { const serviceRef = useLatest(service); const update = useUpdate(); const fetchInstance = useCreation(() =\u003e { return new Fetch(serviceRef, update); }, []); useMount(() =\u003e { // useCachePlugin can set fetchInstance.state.params from cache when init const params = fetchInstance.state.params ?? []; // @ts-ignore fetchInstance.runAsync(...params); }); useUnmount(() =\u003e { fetchInstance.cancel(); }); return { loading: fetchInstance.state.loading, data: fetchInstance.state.data, error: fetchInstance.state.error, params: fetchInstance.state.params || [], cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)), }; }; export default class Fetch\u003cTData, TParams extends any[]\u003e { public count: number = 0; public state = { loading: false, params: undefined, data: undefined, error: undefined, }; constructor(public serviceRef, public subscribe) {} setState(s) { this.state = { ...this.state, ...s, }; this.subscribe(); } async runAsync(...params: TParams): Promise\u003cany\u003e { this.count += 1; const currentCount = this.count; this.setState({ loading: true, params, }); try { const servicePromise = this.serviceRef.current(...params); const res = await servicePromise; if (currentCount !== this.count) { return new Promise(() =\u003e {}); } this.setState({ data: res, error: undefined, loading: false, }); return res; } catch (error) { if (currentCount !== this.count) { // prevent run.then when request is canceled return new Promise(() =\u003e {}); } this.setState({ error, loading: false, }); throw error; } } cancel() { this.count += 1; this.setState({ loading: false, }); } refreshAsync() { // @ts-ignore return this.runAsync(...(this.state.params || [])); } } ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:3:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"实现剩余核心功能 接收用户的自定义配置，包括 manual(手动模式)和一些回调函数（onBefore,onSuccess, onError,onFinally） const useRequestImplement = (service: Promise\u003cany\u003e, options) =\u003e { const { manual = false, ...rest } = options; const fetchOptions = { manual, ...rest, }; // const serviceRef = useLatest(service); // const update = useUpdate(); // const fetchInstance = useCreation(() =\u003e { return new Fetch(serviceRef, fetchOptions, update); // }, []); fetchInstance.options = fetchOptions; useMount(() =\u003e { if (!manual) { const params = fetchInstance.state.params || options.defaultParams || []; // @ts-ignore fetchInstance.run(...params); } }); // useUnmount(() =\u003e { // fetchInstance.cancel(); // }); return { // loading: fetchInstance.state.loading, // data: fetchInstance.state.data, // error: fetchInstance.state.error, // params: fetchInstance.state.params || [], // cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)), refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)), refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)), run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)), runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)), mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance)), }; }; export default class Fetch\u003cTData, TParams extends any[]\u003e { // public count: number = 0; // // public state = { // loading: false, // params: undefined, // data: undefined, // error: undefined, // }; constructor(public serviceRef, public options, public subscribe) { this.state = { ...this.state, loading: !options.manual, }; } // setState(s) { // this.state = { // ...this.state, // ...s, // }; // this.subscribe(); // } // async runAsync(...params: TParams): Promise\u003cany\u003e { // this.count += 1; // const currentCount = this.count; // // this.setState({ // loading: true, // params, // }); // this.options.onBefore?.(params); // try { // const servicePromise = this.serviceRef.current(...params); // const res = await servicePromise; // if (currentCount !== this.count) { // return new Promise(() =\u003e {}); // } // this.setState({ // data: res, // error: undefined, // loading: false, // }); // this.options.onSuccess?.(res, params); this.options.onFinally?.(params, res, undefined); // // return res; // } catch (error) { // if (currentCount !== this.count) { // // prevent run.then when request is canceled // return new Promise(() =\u003e {}); // } // this.setState({ // error, // loading: false, // }); // this.options.onError?.(error, params); this.options.onFinally?.(params, undefined, error); // throw error; // } // } // cancel() { // this.count += 1; // this.setState({ // loading: false, // }); // } // // refreshAsync() { // // @ts-ignore // return this.runAsync(...(this.state.params || [])); // } run(...params: TParams) { this.runAsync(...params).catch((error) =\u003e { if (!this.options.onError) { console.error(error); } }); } refresh() { // @ts-ignore this.run(...(this.state.params || [])); } mutate(data?: TData | ((oldData?: TData) =\u003e TData | undefined)) { const targetData = isFunction(data) ? data(this.state.data) : data; this.setState({ data: targetData, }); } } runAsync 和 run runAsync 方法返回一个 promise，使用 runAsync 时，当请求报错会中断后续操作，需要手动捕获异常。 run 方法则对 runAsync 进行了封装，帮助我们了捕获异常，或可以通过 options.onError 来处理异常行为。 refresh 和 refreshAsync useRequest 维护了一份 params，调用 run()和 runAsync()的时候会同时更新 params。以便给 refresh 和 refreshAsync 方法使用 cancel useRequest 维护了一个 count。 而 runAsync 方法本身也维护一个 currentCount。 每次调用 runAsync 时，count 进行一次++操作，然后将其赋值给 currentCount。 每次 cancel 方法 count 会再进行一次++操作。通过比较 count 和 currentCount 的值来判断用户是否进行了取消操作，进行相应的处理 mutate 支持立即修改 useRequest 返回的 data 参数。 mutate 的用法与 React.setState 一致，支持 mutate(newData) 和 mutate((oldData) =\u003e newData) 两种写法。 ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:4:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"小结 以上是 useRequest hook 的基本功能，剩余功能如 loading 状态延时、请求防抖、节流、数据缓存等功能都是通过插件的形式进行实现的，具体实现可以看 ahooks 中的核心 hook-useRequest（下） ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:5:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-10-23","objectID":"/myblog/react-router-v6/","tags":["react","学习笔记"],"title":"react-router v6","uri":"/myblog/react-router-v6/"},{"categories":["前端"],"content":"前言 之前一直负责老项目的迭代，而且很少关注 router 相关的代码，直到上个月公司开了一个新项目，当我着手开始配置路由时突然发现，嗯？Switch 标签咋没了？Route 里的 component 属性咋也没了。意识到不妙的我赶紧去翻了翻 react router 的文档，发现 react router 早就在 21 年底就偷偷升级到了 v6 且变更极大（嗯 这是一个悲伤的故事，现在甚至已经更新到了 6.4.1） 之前的老项目的包版本是 5.2 的，要升级的话成本有点高，也懒得搞，就那样吧。但新项目肯定不能将就啊。那就整呗 ","date":"2022-10-23","objectID":"/myblog/react-router-v6/:0:1","tags":["react","学习笔记"],"title":"react-router v6","uri":"/myblog/react-router-v6/"},{"categories":["前端"],"content":"正文 首先先说一下 react-router 和 react-router-dom 的区别，react-router 实现了路由的核心功能，react-router-dom 则是基于 react-router，又加了在浏览器运行环境下的一些功能，比如把 Link 组件渲染成一个 a 标签，再比如 HashRouter 会使用 window.location.hash 和 hashChange 事件构建路由。一般在项目中只需要引入 react-router-dom 包即可。 npm install react-router-dom BrowserRouter 新项目使用浏览器路由即 BrowserRouter，要想在项目中使用 React Router，需要 App 组件嵌套进 BrowserRouter 组件中。 ReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement).render( \u003cReact.StrictMode\u003e \u003cBrowserRouter\u003e \u003cApp /\u003e \u003c/BrowserRouter\u003e \u003c/React.StrictMode\u003e ); Routes 和 Route 我们使用 Route 组件来定义路由，并使用 Routes 包裹。 Route 组件接收两个 props： path?: string | 页面 url element?： React.ReactNode |当前 url 需要加载的元素 \u003cRoutes\u003e \u003cRoute path=\"/\" element={\u003cHome /\u003e} /\u003e \u003cRoute path=\"/teams/:id\" element={\u003cTeams /\u003e} /\u003e \u003cRoute path=\"/teams/new\" element={\u003cNewTeams /\u003e} /\u003e \u003cRoute path=\"*\" element={\u003cPageError /\u003e} /\u003e \u003c/Routes\u003e \u003cSwitch\u003e \u003cRoute path=\"/teams/:id\" component={Teams} /\u003e \u003cRoute path=\"/teams/new\" component={NewTeams} /\u003e \u003c/Switch\u003e V6 的 Route 组件不在要求我们按一定的顺序来定义路由,在旧版本中，当多个路由匹配一个模糊的 url 时，我们必须以某种方式对路由进行排序，v6 版本则会替我们选择最具体的匹配。/teams/new 将匹配这两个路由，但只会渲染 NewTeams 组件。 支持的格式： /groups /groups/admin /users/:id /users/:id/messages /files/* /files/:id/* 嵌套路由 react-router V6 支持路由的嵌套，允许父路由控制子路由的渲染， 提供了一个渲染出口组件 Outlet，当匹配到子路由的时候会渲染在 Outlet 组件所在的位置，父路由此时仍然存在。 支持多级嵌套 const src = () =\u003e { return ( \u003c\u003e \u003cRoutes\u003e \u003cRoute path=\"/\" element={\u003cHome /\u003e} /\u003e \u003cRoute path=\"/list\" element={\u003cList /\u003e}\u003e \u003cRoute path=\"Detail/:id\" element={\u003cDetail /\u003e} /\u003e \u003c/Route\u003e \u003c/Routes\u003e \u003c/\u003e ) } const List = () =\u003e { const navigate = useNavigate(); return ( \u003c\u003e \u003cdiv className=\"list\"\u003e \u003cButton onClick={() =\u003e { navigate('/list/detail/1'); }} \u003e detail1 \u003c/Button\u003e \u003cButton onClick={() =\u003e { navigate('/list/detail/2'); }} \u003e detail2 \u003c/Button\u003e // react-router提供了Outlet组件用来占位置 \u003cOutlet /\u003e \u003c/div\u003e \u003c/\u003e ); 查询参数 /mysql?mysql_group_id=mysql-test\u0026mysql_instance_id=mysql-asfasfew react-router V6 提供了 useSearchParams Hook，它是基于浏览器内置的 URLSearchParams 构造函数进行的封装。 useSearchParams 类似 useState，返回一个数组，第一个元素是一个 Map，可以通过其 get 方法获取查询字符串中的值，第二个元素是一个函数，用来更新 url 中的查询字符串。 import { useSearchParams } from 'react-router-dom'; const [searchParams, setSearchParams] = useSearchParams(); const groupId = searchParams.get('mysql_group_id') const instanceId = searchParams.get('mysql_instance_id') const updateOrder = (sort) =\u003e { setSearchParams({ key: value }) } 编程式配置路由 react-router V6 还提供了 useRoutes Hook，使我们可以通过写一个配置对象的方式来配置路由，不需要在自行拼接 jsx. const routerConfig = [ { path: \"/\", key: \"home\", label: \"common.nav.menu.home\", icon: \u003cHomeOutlined /\u003e, element: \u003cHome /\u003e, }, { key: \"authManageWrapper\", label: \"common.nav.menu.authManage\", icon: \u003cSolutionOutlined /\u003e, children: [ { path: \"/auth/list\", key: \"authList\", label: \"common.nav.menu.authList\", element: \u003cAuthList /\u003e, }, { path: \"/auth/add\", key: \"addAuth\", label: \"common.nav.menu.addAuth\", element: \u003cAddAuth /\u003e, }, ], }, { path: \"*\", hideInMenu: true, key: \"null\", element: \u003cNavigate to=\"/\" /\u003e, }, ] return ( \u003c\u003e {useRoutes(routerConfig)} \u003c/\u003e ) 在 antd 的 4.20 版本+中，他的 Menu 导航组件也支持这种写法，可以维护一份 routerConfig，对其扩充一些属性，就能同时再 Menu 组件中使用。 其他 新增 useNavigate Hook 代替 useHistory Hook let navigate = useNavigate(); \u003cbutton onClick={() =\u003e { navigate(\"/invoices\" + location.search); }} \u003e jump \u003c/button\u003e 可以在各个地方渲染多组路由：经常有一些需求让我们在某个 state 为 true 时展示组件 A，为 false 时展示组件 B，这个时候可以尝试在组件内写一个嵌套路由。 总结： 定义路由时 Routes 组件和 Route 组件搭配使用，且可以在不同地方定义多组。Route 组件的属性也发生了变更。 新增了 Outlet 组件，支持路由的嵌套，使用起来可以更加的灵活。 新增了一个可以查询和更新 url 参数的 hook useSearchParams。 提供了 useRoutes Hook， 支持使用 js 对象的形式来定义路由。 ","date":"2022-10-23","objectID":"/myblog/react-router-v6/:0:2","tags":["react","学习笔记"],"title":"react-router v6","uri":"/myblog/react-router-v6/"},{"categories":["前端"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"红宝书（学习笔记） ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"三、语言基础 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"null 和 undefined（3.4） null: 表示一个空对象指针。这也是 typeof null 会返回‘object’的原因。 undefined： undefined 值由 null 派生而来，所以表面相等（null == undefined // true） 当声明了变量但未赋值的时候，就相当于给变量赋值了 undefined； 当访问对象变量中不存在的属性时会返回 undefined； 区别： 在定义一个将要保存对象值得变量来说，可以使用 null 来初始化 但不建议给某个变量设置 undefined 值。字面值 undefined 主要用于比较 （undefined可以用来**读**，null可以用来**读写**） Number(null) return 0; Number(undefined) return NaN ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"Symbol 类型（3.4） 之前没仔细了解过，原来 Symbol 还有几个 api 如果想重用符号实例，可以通过 Symbol.for()方法 const a = Symbol('a'); const b = Symbol('a'); console.log(a == b); //false const c = Symbol.for('a'); const d = Symbol.for('a'); console.log(a == b); //true // 注： const e = Symbol('a'); const f = Symbol.for('a'); console.log(a == b); //false 还可以对其进行查询 const g = Symbol.for('a'); console.log(Symbol.keyFor(g)); // 'a' const h = Symbol('a'); console.log(Symbol.keyFor(h)); // undefined console.log(Symbol.keyFor(123)); // TypeError 123 is not a symbol 当 Symbol 符号作为对象的键的时候，是不会被 Object.keys 或 entries 等相关 api 遍历出来的, 可以通过 Object.getOwnPropertySymbols()等来拿到对象的 symbol 类型键值 const a = Symbol('a'); const b = Symbol('b'); const obj = {}; obj[a] = '123'; obj[b] = '456'; obj['c'] = '789'; console.log(obj); // {c: '789', Symbol(a): '123', Symbol(b): '456'} Object.keys(obj); // ['c']; Object.values(obj); // ['789']; Object.getOwnPropertyNames(obj); // ['c']; Object.getOwnPropertySymbols(obj); // [Symbol(a), Symbol(b)]; Object.getOwnPropertyDescriptors(obj); // [Symbol(a), Symbol(b)]; // 或者通过Reflect.ownKeys()拿到两个类型的键 Reflect.ownKeys(obj); // ['c', Symbol(a), Symbol(b)]; ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"四、变量、作用域与内存 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"原始值与引用值（4.1） 变量可以包含两种类型的数据，原始值和引用值， 原始值就是最简单的数据（string， number，symbol，undefined，null, boolean） 引用值则是由多个值构成的对象。 typeof 可以确认值的原始值类型，instanceof 可以用于确认值的引用类型 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"六、集合引用类型 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"array.form() (6.2.1) Array.form()除了能将类数组结构转换为数组实例外，还能进行类似 map 操作 Array.from()方法有一个可选参数 mapFn，让你可以在最后生成的数组上再执行一次 map 方法后再返回。也就是说` Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg) ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"八、对象、类与面向对象编程 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"理解对象（8.1） 对象： 一组属性的无序集合，他的每个属性或方法都有一个名称来标识； 对象的属性有两种类型，数据属性和访问器属性，ECMA 使用了一些内部特性来描述属性的特征 数据属性：数据属性包含一个保存数据值的位置用来读写，他有四个特性 [[Configurable]]: 表示当前属性是否可以通过 delete 删除以及是否可以把它改为访问器属性，默认为 true [[Enumberable]]: 表示属性是否可以通过 for-in 循环返回，默认为 true [[Writable]]: 表示属性值是否支持修改，默认为 true [[Value]]: 包含属性实际的值，默认为 undefined。 let obj = { name: 'Xiaoming' } // 这就意味着obj这个对象的name属性的特性[[Value]]会被设置为'Xiaoming' //可以通过Object.defineProperty()方法来修改属性的默认特性 // Object.defineProperty(objName, attrName, descriptor) // objName: 要修改的对象名称； // attrName: 要修改的对象的属性名称； // descriptor: 要修改的描述符对象(Configurable、Enumberable、Writable、Value)。 const person = {} // 设置只读 Object.defineProperty(person, 'name', { writable: false, value: 'Xiaoming', }) console.log(person.name) // Xiaoming; person.name = 'Xiaohong' console.log(person.name) // Xiaoming; // 设置不可删除 Object.defineProperty(person, 'name', { configurable: false, }) delete person.name; console.log(person.name) // Xiaoming; 访问器属性: 访问器属性不包含数据值，相反，他们包含一个获取函数（getter）和设置函数（setter），在读取访问器属性时，会调用获取函数，在写入访问器属性时会调用设置函数。同样他也有 4 个特性来描述他的行为: [[Configurable]]: 表示当前属性是否可以通过 delete 删除以及是否可以把它改为访问器属性，默认为 true [[Enumberable]]: 表示属性是否可以通过 for-in 循环返回，默认为 true 【注】访问器属性是不能直接定义的，必须使用 Object.defineProperty() const person { age_: 28, } Object.definedProperty(person, 'age', { get() { return this.age_ + 1; } set(newValue) { this.age_ = newValue * 2; } }) console.log(person.age_) // 28; console.log(person.age) // 29; person.age = 10; console.log(person.age_) // 20; console.log(person.age) // 21; // 获取函数和设置函数不一定都要定义，只设置获取函数意味着属性是只读的，只设置设置函数的属性意味着属性不能进行读取 可以通过 Object.getOwnPropertyDescriptor(objName, attrName?: string)方法来取得指定属性的属性描述符 const person = {name: 'Xiaoming'} console.log(Object.getOwnDefinePropertyDescriptor(person, 'name')) // { // configurable: true, // enumerable: true, // writable: true, // value: 'Xiaoming', //} ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"对象标识及相等判定（8.1.5） 除了能通过 isNaN（）来判断变量是否是 NaN，还可以通过 Object.is(); console.log(NaN === NaN) // false; console.log(isNaN(NaN)) // true; console.log(Object.is(NaN, NaN)) // true; ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"判断对象中是否包含某个属性 // 判断对象实例或原型是否包含某个实例 const obj = {name: 'xiaoMing'}; console.log('name' in obj) // true; console.log('age' in obj) // false; //判断对象实例是否包含某个实例 function Person(){}; Person.prototype.name = 'xiaoMing'; let son = new Person(); console.log(son.name) // 'xiaoMing; console.log(son.hasOwnProperty('name')) // false; ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"排序的分类 时间复杂度（O(n^2)）: 冒泡、插入、选择； 时间复杂度（O(nLogn)）: 快排，归并； 时间复杂度（O(n)）: 桶，计数，基数； ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"如何分析一个排序算法 ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"执行效率（时间复杂度）： 最好情况、最坏情况、平均情况； 时间复杂度的系数、常数、低阶：时间复杂度反映的是数据规模 n 很大的时候的增长趋势，所以他会忽略掉系数、常数和低阶。但实际开发中，面对一些规模很小的数据时，为了相对精确的比较不同算法的执行效率，就需要把系数、常数、低阶也考虑进去。 ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:2:1","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"内存消耗（空间复杂度）； ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:2:2","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"稳定性：指的是如果在待排序的序列中存在值相等的元素，经过排序后，相等元素之间的顺序是否发生变化 ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:2:3","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"冒泡排序 从下标 0 开始，对相邻的数据进行比较，不满足条件则互换位置。 一轮冒泡会让至少一个元素移动到他应该在的位置。重复 n 次。就完成了 n 个数据的排序。 {% img /images/bubbling.webp %} 可以看到，经过一次排序后，6 已经挪到了末尾。执行 6 次后，排序完成。 两个优化点： 当某一轮冒泡期间，没有数据交换的操作，意味着已经达到完全有序，就无须在进行后续的冒泡操作了。 每一轮冒泡后，都会至少确认一个元素的位置于末尾。因此，每轮冒泡相对于上一轮都可以少比较一次。（如图例，第一轮冒泡需要比较 6 个元素，第二轮则只需要比较前 5 个元素） // 冒泡排序 const bobbleSort = (arr) =\u003e { if (arr.length \u003c= 1) return arr; for(let i = 0; i \u003c arr.length; i++) { let flag = true; for(let j = 0; j \u003c arr.length - i; j++) { if (arr[j] \u003e arr[j + 1]) { let temp = arr[j]; arr[j] = arr[j + 1]; arr[j] = temp; flag = false; } } if (flag) break; } } ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:3:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"插入排序 首先将数组中的数据分为两个区间，已排序区间和未排序区间。（初始，已排序区间只有一个元素如第一个元素） 插入排序的核心思想： 遍历未排序区间的元素，在已排序区间中找到合适的位置，插入进去，并保证已排序区间一直有序。知道未排序区间中的元素为空。 {% img /images/insertionSort.webp %} 把数据 a 插入已排序区间：需要拿 a 与已排序区间的元素依次进行比较，找到合适的位置插入进去。 // 插入排序 const insertionSort = (arr) =\u003e { if (arr.length \u003c= 1) return; // 1. 遍历未排序区间的元素。 for (let i =1; i\u003c arr.length; i++) { // 2. 当前要进行比较插入的未排序区间元素 let value = a[i]; // 3. value元素的上一个元素下标。 let j = i - 1; // 4. 从 下标j开始，往下标0依次进行比较，直到找到value应该插入的位置 for(; j \u003e= 0; j--) { if（arr[j] \u003e value）{ arr[j + 1] = arr[j]; } else { break; } } //插入数据value； arr[j + 1] = value; } } ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:4:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"选择排序 类似于插入排序，也有已排序区间和未排序区间，已排序区间默认为空， 在未排序区间找到最小值，插入已排序区间的末尾； // 选择排序 const selectionSort = (arr) =\u003e { if (arr.length \u003c= 1) return; for (let i = 0; i \u003c arr.length; i++) { let minIndex = i; for (let j = i+1; j\u003c arr.length; j++) { minIndex = arr[minIndex] \u003c arr[j] ? minIndex : j; } const temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } console.log(arr); return arr; } ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:5:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"比较冒泡排序和插入排序 冒泡排序的数据交换比插入排序的数据移动要复杂，冒泡排序需要三个赋值操作，而插入排序只需要一个 // 冒泡排序 if（a[j] \u003e a[j + 1]） { let temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; }; //插入排序 if (a[j] \u003e value) { a[j + 1] = a[j]; } else { break; }; 总结： {% img /images/sortSummary.webp %} ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:6:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"递归 描述： 一种非常高效、简洁的编程技巧。函数调用自身的方式称为递归调用，调用成为递，返回称为归； 正确姿势：找到如何将大问题分解为小问题的规律，并基于此写出递推公式。然后再敲定终止条件，生成递归函数。 ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:0:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"优缺点： 优点：代码简洁，表达力强 缺点： 空间复杂度高，有堆栈溢出风险、存在重复计算、过多函数调用会耗时较多等问题。 ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"递归需要满足的三个条件： 一个人问题的解可以分解为几个子问题（数据规模更小的问题）的解； 这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样； 存在递归终止条件：把问题分解为子问题，把子问题再分解为子子问题，一层层分解下去，这就需要一个终止条件，防止无限分解； ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"练习题： 假设有 n 个台阶，每次你可以跨一个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？ 提示： 如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，2，1 这样子上去。 解： 我们可以根据 第一步 的走法把所有走法分为两类， 第一类是第一步走了 1 个台阶 第二类是第一步走了 2 个台阶 所以，n 个台阶的走法 = 先走 1 个台阶后，n-1 个台阶的走法 + 先走 2 个台阶后，n-1 个台阶的走法。 得到求解公式： f(n) = f(n-1) + f(n-2) 找到终止条件： 当有一个台阶时，只有一个走法，结束递归，f(1) = 1；当有两个台阶时，有两个走法，结束递归，f(2）= 2； 通过求解公式和终止条件，可以得到一个递归函数求出所有走法的总数 const func = (num) =\u003e { if (n === 1) return 1; if (n === 2) return 2; return f(n-1) + f(n-2); } ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:3:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"技巧 如果一个问题 A 可以分解为若干个子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。屏蔽掉递归细节，把它抽象成一个递推公式，不要想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:4:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"递归的问题： 要警惕堆栈溢出：函数调用会使用栈来保存临时变量每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈，系统栈和虚拟机栈空间一般都不大，如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。 解决：尽可能的限制递归深度和运算的复杂度 要警惕重复计算：如果把上题的递归过程拆解，如下图： {% img /images/recursion.webp %} 我们可以直观的看到，想要计算 f(5)，需要先计算 f(4)和 f(3)，而计算 f(4)同样需要计算 f(3)，因此，f(3)就被计算了很多次，这就是重复计算问题。 解决：可以将求解过的 f(k)保存起来，当递归调用到 f(k)时先看下是否已经求解过了，是则直接取值返回。 const returnList = {}; const func = (num) =\u003e { if (n === 1) return 1; if (n === 2) return 2; if (returnList[n]) { return rerutnList[n] } const val = f(n-1) + f(n-2) returnList[n] = val; return val; } 要警惕无限递归问题： 解决： 一定要保证终止条件是有效且合理的， ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:5:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-06","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（三）栈与队列","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"栈 栈是一种操作受限的线性表，只允许在一端插入（push()）和删除（pop()）数据。 特性： 后进者先出，先进者后出 使用场景： 如浏览器的前进、后退功能 ","date":"2022-01-06","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:0:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（三）栈与队列","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"使用数组实现一个简易的栈结构 class CreateStack { private stack: any[] = []; public push(item: any) { this.stack.push(item); return true; } public pop() { if (this.stack.length === 0) { return null; } const tmp = this.stack[this.stack.length - 1]; this.stack.pop(); return tmp; } } 队列 队列和栈非常的相似，最基本的操作也是两个： 入队（enqueue()），放一个数据到队列的尾部，出队（dequeue()）,从队头取出一个数据。 特性： 先进先出。 ","date":"2022-01-06","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（三）栈与队列","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"使用数组实现一个简易的队列结构 class CreateStack { private stack: any[] = []; private headIndex: number = 0； public enqueue(item: any) { this.stack.push(item); return true; } public dequeue() { if (this.stack.length === headIndex) { return null; } const tmp = this.stack[headIndex]; ++headIndex; return tmp; } } ","date":"2022-01-06","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（三）栈与队列","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"数组 数组是一种线性表数据结构，用一组连续的内存空间来存储数据 线性表： 线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向， 其他线性表数据结构：链表、队列、栈。 {% img /images/LinearTable.webp %} 非线性表： 数据之间不是简单的前后关系 {% img /images/NotLinearTable.webp %} 链表 与数组不同， 他并不需要一块连续的内存空间，他可以通过指针将一组零散的内存块串联起来使用。 {% img /images/LinkedList.webp %} 最常见的三种链表结构： 单链表，双向链表，循环链表。 ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:0:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"单链表 链表通过指针将一串零散的内存块串联在一起，其中，内存块称为链表的节点，为了把所有的节点串起来，每个链表的节点除了存储数据外，还需要记录下一个链表的地址，我们把这个记录下个节点地址的指针叫做后继指针 next {% img /images/SingleLinkedList.webp %} 头节点和尾节点两个节点比较特殊， 头结点用来记录链表的基地址，有了它，就可以遍历得到整条链表。 尾结点则指向一个空地址 null，表示这是链表的最后一个节点。 {% img /images/LinkedListAction.webp %} ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"循环链表 循环链表是特殊的单链表，和单链表的区别就在于尾结点，循环链表的尾结点指向链表的头结点 {% img /images/CircularLinkedList.webp %} ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"双向链表 单链表只有一个方向，节点只有一个后继指针 next 指向后面的节点，双向链表则多了一个前驱指针 prev 指向前面的节点，支持双向遍历，增加了灵活性。 同样的，既然多出一个空间用来存储前驱节点，所以，当存储同样多的数据时，双向链表要比单链表占据更多的内存空间 {% img /images/BidirectionalLinkedList.webp %} ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:3:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"链表的相关操作 ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:4:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"插入节点 // 将节点插入到node后面 new_node-\u003enext = node-\u003enext node = new_node ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:4:1","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"删除节点 // 删除节点node的后继节点 node-\u003enext = node-\u003enext-\u003enext 总结： 数组和链表的区别： 存储结构： 数组： 连续的内存空间；可以借助 CPU 的缓存机制，预读数组中的数据，访问效率更高。 链表： 一组零散的内存块；对 CPU 缓存不友好，没办法有效预读。 插入，删除操作的复杂度： 数组： 数组结构的在进行插入、删除操作时，为了保证整体的连续性，需要做大量的数据迁移，时间复杂度为 O(n)。 链表： 链表的存储空间本身就是不连续的，只需要关注考虑相邻接点的指针改变，总时间复杂度是 O(1)。 （延伸：尽管单纯的删除操作， 时间复杂度是 O(1)，但删除某个节点 q，需要知道上一个节点的地址，单链表寻找上一个节点仍需遍历查找，时间复杂度为 O(n)，总时间为找+删=O(n)；） 随机访问： 数组： 可以通过下标计算出对应的内存地址，时间复杂度为 O(1)。 链表： 因为链表数据不是不是连续储存的，所以无法像数组一样根据首地址和下标计算出对应的内存地址，只能通过指针一个个节点进行遍历的方法寻找相应的节点。链表的每个节点都只知道自己的下一个节点的地址，当我们想知道第 k 个节点的时候，只能从第一个开始往下数，时间复杂度是 O(n)。 ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:4:2","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["数据结构与算法"],"content":"开头 好记性不如烂笔头，在这里记录下学习数据结构与算法之美的笔记 ","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["数据结构与算法"],"content":"简述 数据结构指的是‘一组数据的存储结构’，算法指的是’操作数据的一种方法‘。 数据结构是为算法服务的，算法要作用在特定的数据结构之上。 ","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["数据结构与算法"],"content":"正片 ","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["数据结构与算法"],"content":"复杂度分析 时间复杂度 （大 O 复杂度表示法） 算法的执行效率，粗略的讲，就是算法代码的执行时间。 const (n) =\u003e { const sum = 0; const i = 1; for (; i \u003c= n; ++i) { sum = sum + i; }; return sum } 假设每行代码执行的时间都一样，为 o,那么 第 2, 3 行分别需要一个 o 的执行时间； 第 4, 5 行都运行了 n 次，所以需要 2 个 n* o 的执行时间； 这段代码的总执行时间就是：（2n + 2）* o。 可以看出，每行代码的执行次数越多，总执行时间 T(n)就越高。按照这个思路，再看一段代码 const (n) =\u003e { const sum = 0; const i = 1; for (; i \u003c= n; ++i) { const j = 1; for (; j \u003c= n; ++j) { sum = sum + i + j; } }; return sum } 第 2、3、5 行需要一个 o 的执行时间； 第 4、5 行执行了 n 遍，需要 2 个 n * o 的执行时间； 第 7、8 行执行了 n^2 遍，需要 2 个 n^2 * o 的执行时间； 总执行时间为(2n^2 + 2n + 3) * o。 通过推导，得到一个公式T(n) = O(f(n)) t(n)表示代码的执行时间，f(n)表示代码执行次数的总和，所以，第一个例子中的 T(n) = O(2n + 2)和第二个例子的 T(n) = O(2n^2 + 2n + 3)。这就是大 O 时间复杂度表示法，他并不能具体表示代码的真正执行时间，而是表示代码执行时间随数据规模增长的变化趋势。 其中，f(n)中的低阶、常量、系数、三部分对增长趋势不产生绝对影响（在（2n^2 + 2n + 3）中，低阶是 2n、常量是 3、系数是 2），所以都可以省略，我们只需要记录一个最大量级就可以，因此，前两个例子的事件复杂度可以记为T(n) = O(n); T(n) = O(n^2)。 几种常见的时间复杂度 （按数量级排列） 常量阶： O(1) // 只要代码的执行时间不随n的增大而增大，这样代码的时间复杂度都记作O(1) const func = (n) =\u003e { const a = 1; const b = 2; return a + b; }; 对数阶： O(log n) let i = 1; while (i \u003c= n) { i = i * 2; } 线性阶： O(n) 线性对数阶： O(n * log n) 平方阶： O(n^2)、立方阶： O（n^3）…… 指数阶： O(2^n) 阶乘阶： O(n!) 空间复杂度 与时间复杂度同理，表示算法的存储空间与数据规模的增长关系。 常见的空间复杂度 O(1)、O(n)、o(n^2) ","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:1","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["documentation"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念.","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"探索 Hugo - LoveIt 主题的全部内容和背后的核心概念. ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:0:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"1 准备 由于 Hugo 提供的便利性, Hugo 本身是这个主题唯一的依赖. 直接安装满足你操作系统 (Windows, Linux, macOS) 的最新版本  Hugo (\u003e 0.62.0). 为什么不支持早期版本的 Hugo? 由于 Markdown 渲染钩子函数 在 Hugo 圣诞节版本 中被引入, 本主题只支持高于 0.62.0 的 Hugo 版本. 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将  SCSS 转换为  CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:1:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"2 安装 以下步骤可帮助你初始化新网站. 如果你根本不了解 Hugo, 我们强烈建议你按照此 快速入门文档 进一步了解它. ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:2:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.1 创建你的项目 Hugo 提供了一个 new 命令来创建一个新的网站: hugo new site my_website cd my_website ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:2:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.2 安装主题 LoveIt 主题的仓库是: https://github.com/dillonzq/LoveIt. 你可以下载主题的 最新版本  .zip 文件 并且解压放到 themes 目录. 另外, 也可以直接把这个主题克隆到 themes 目录: git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 或者, 初始化你的项目目录为 git 仓库, 并且把主题仓库作为你的网站目录的子模块: git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:2:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false 注意 在构建网站时, 你可以使用 --theme 选项设置主题. 但是, 我建议你修改配置文件 (config.toml) 将本主题设置为默认主题. ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:2:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 通过添加一些示例内容并替换文件开头的标题, 你可以随意编辑文章. 注意 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:2:4","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 基本配置下的预览 技巧 当你运行 hugo serve 时, 当文件内容更改时, 页面会随着更改自动刷新. 注意 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:2:5","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 技巧 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:2:6","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"3 配置 ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:3:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : baseURL = \"http://example.org/\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" # 网站标题 title = \"我的全新 Hugo 网站\" # 网站语言, 仅在这里 CN 大写 [\"en\", \"zh-CN\", \"fr\", \"pl\", ...] languageCode = \"zh-CN\" # 语言名称 [\"English\", \"简体中文\", \"Français\", \"Polski\", ...] languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true # 默认每页列表显示的文章数目 paginate = 12 # 谷歌分析代号 [UA-XXXXXXXX-X] googleAnalytics = \"\" # 版权描述，仅仅用于 SEO copyright = \"\" # 是否使用 robots.txt enableRobotsTXT = true # 是否使用 git 信息 enableGitInfo = true # 是否使用 emoji 代码 enableEmoji = true # 忽略一些构建错误 ignoreErrors = [\"error-remote-getjson\", \"error-missing-instagram-accesstoken\"] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" # 菜单配置 [menu] [[menu.main]] weight = 1 identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" [[menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [params] # 网站默认主题样式 [\"auto\", \"light\", \"dark\"] defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # [\"sha256\", \"sha384\", \"sha512\", \"md5\"] fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站标题, 用于 Open Graph 和 Twitter Cards title = \"我的网站\" # 网站描述, 用于 RSS, SEO, Open Graph 和 Twitter Cards description = \"这是我的全新 Hugo 网站\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 [\"fixed\", \"normal\", \"auto\"] desktopMode = \"fixed\" # 移动端导航栏模式 [\"fixed\", \"normal\", \"auto\"] mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"我的网站\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 (允许 HTML 格式) subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtu","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:3:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.2 网站图标, 浏览器配置, 网站清单 强烈建议你把: apple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在 /static 目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义 browserconfig.xml 和 site.webmanifest 文件来设置 theme-color 和 background-color. ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:3:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"3.3 自定义样式 注意 Hugo extended 版本对于自定义样式是必需的. 通过定义自定义 .scss 样式文件, LoveIt 主题支持可配置的样式. 包含自定义 .scss 样式文件的目录相对于 你的项目根目录 的路径为 assets/css. 在 assets/css/_override.scss 中, 你可以覆盖 themes/LoveIt/assets/css/_variables.scss 中的变量以自定义样式. 这是一个例子: @import url('https://fonts.googleapis.com/css?family=Fira+Mono:400,700\u0026display=swap\u0026subset=latin-ext'); $code-font-family: Fira Mono, Source Code Pro, Menlo, Consolas, Monaco, monospace; 在 assets/css/_custom.scss 中, 你可以添加一些 CSS 样式代码以自定义样式. ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:3:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"4 多语言和 i18n LoveIt 主题完全兼容 Hugo 的多语言模式, 并且支持在网页上切换语言. 语言切换 ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:4:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.1 兼容性 语言 Hugo 代码 HTML lang 属性 主题文档 Lunr.js 支持 英语 en en 简体中文 zh-cn zh-CN 繁體中文 zh-tw zh-TW 法语 fr fr 波兰语 pl pl 巴西葡萄牙语 pt-br pt-BR 意大利语 it it 西班牙语 es es 德语 de de 塞尔维亚语 pl pl 俄语 ru ru 罗马尼亚语 ro ro 越南语 vi vi 阿拉伯语 ar ar 加泰罗尼亚语 ca ca 泰语 th th 泰卢固语 te te 印尼语 id id 土耳其语 tr tr 韩语 ko ko 印地语 hi hi ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:4:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.2 基本配置 学习了 Hugo 如何处理多语言网站 之后, 请在 站点配置 中定义你的网站语言. 例如, 一个支持英语, 中文和法语的网站配置: # 设置默认的语言 [\"en\", \"zh-cn\", \"fr\", \"pl\", ...] defaultContentLanguage = \"zh-cn\" [languages] [languages.en] weight = 1 title = \"My New Hugo Site\" languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" [[languages.en.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" [[languages.en.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" [languages.zh-cn] weight = 2 title = \"我的全新 Hugo 网站\" languageCode = \"zh-CN\" languageName = \"简体中文\" hasCJKLanguage = true [[languages.zh-cn.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" [[languages.zh-cn.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" [[languages.zh-cn.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" [languages.fr] weight = 3 title = \"Mon nouveau site Hugo\" languageCode = \"fr\" languageName = \"Français\" [[languages.fr.menu.main]] weight = 1 identifier = \"posts\" pre = \"\" post = \"\" name = \"Postes\" url = \"/posts/\" title = \"\" [[languages.fr.menu.main]] weight = 2 identifier = \"tags\" pre = \"\" post = \"\" name = \"Balises\" url = \"/tags/\" title = \"\" [[languages.fr.menu.main]] weight = 3 identifier = \"categories\" pre = \"\" post = \"\" name = \"Catégories\" url = \"/categories/\" title = \"\" 然后, 对于每个新页面, 将语言代码附加到文件名中. 单个文件 my-page.md 需要分为三个文件: 英语: my-page.en.md 中文: my-page.zh-cn.md 法语: my-page.fr.md 注意 请注意, 菜单中仅显示翻译的页面. 它不会替换为默认语言内容. 技巧 也可以使用 文章前置参数 来翻译网址. ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:4:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"4.3 修改默认的翻译字符串 翻译字符串用于在主题中使用的常见默认值. 目前提供一些语言的翻译, 但你可能自定义其他语言或覆盖默认值. 要覆盖默认值, 请在你项目的 i18n 目录 i18n/\u003clanguageCode\u003e.toml 中创建一个新文件，并从 themes/LoveIt/i18n/en.toml 中获得提示. 另外, 由于你的翻译可能会帮助到其他人, 请花点时间通过  创建一个 PR 来贡献主题翻译, 谢谢! ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:4:3","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"5 搜索 基于 Lunr.js 或 algolia, LoveIt 主题支持搜索功能. ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:5:0","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.1 输出配置 为了生成搜索功能所需要的 index.json, 请在你的 网站配置 中添加 JSON 输出文件类型到 outputs 部分的 home 字段中. [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:5:1","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"5.2 搜索配置 基于 Hugo 生成的 index.json 文件, 你可以激活搜索功能. 这是你的 网站配置 中的搜索部分: [params.search] enable = true # 搜索引擎的类型 [\"lunr\", \"algolia\"] type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" 怎样选择搜索引擎? 以下是两种搜索引擎的对比: lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 文章内容被 h2 和 h3 HTML 标签切分来提高查询效果并且基本实现全文搜索. contentLength 用来限制 h2 和 h3 HTML 标签开头的内容部分的最大长度. 关于 algolia 的使用技巧 你需要上传 index.json 到 algolia 来激活搜索功能. 你可以使用浏览器来上传 index.json 文件但是一个自动化的脚本可能效果更好. 官方提供的 Algolia CLI 是一个不错的选择. 为了兼容 Hugo 的多语言模式, 你需要上传不同语言的 index.json 文件到对应的 algolia index, 例如 zh-cn/index.json 或 fr/index.json… ","date":"2020-03-06","objectID":"/myblog/theme-documentation-basics/:5:2","tags":["installation","configuration"],"title":"主题文档 - 基本概念","uri":"/myblog/theme-documentation-basics/"},{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容.","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"了解如何在 LoveIt 主题中快速, 直观地创建和组织内容. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:0:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"1 内容组织 以下是一些方便你清晰管理和生成文章的目录结构建议: 保持博客文章存放在 content/posts 目录, 例如: content/posts/我的第一篇文章.md 保持简单的静态页面存放在 content 目录, 例如: content/about.md 本地资源组织 本地资源引用 有三种方法来引用图片和音乐等本地资源: 使用页面包中的页面资源. 你可以使用适用于 Resources.GetMatch 的值或者直接使用相对于当前页面目录的文件路径来引用页面资源. 将本地资源放在 assets 目录中, 默认路径是 /assets. 引用资源的文件路径是相对于 assets 目录的. 将本地资源放在 static 目录中, 默认路径是 /static. 引用资源的文件路径是相对于 static 目录的. 引用的优先级符合以上的顺序. 在这个主题中的很多地方可以使用上面的本地资源引用, 例如 链接, 图片, image shortcode, music shortcode 和前置参数中的部分参数. 页面资源或者 assets 目录中的图片处理会在未来的版本中得到支持. 非常酷的功能! ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:1:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"2 前置参数 Hugo 允许你在文章内容前面添加 yaml, toml 或者 json 格式的前置参数. 注意 不是所有的以下前置参数都必须在你的每篇文章中设置. 只有在文章的参数和你的 网站设置 中的 page 部分不一致时才有必要这么做. 这是一个前置参数例子: --- title: '我的第一篇文章' subtitle: '' date: 2020-03-04T15:58:26+08:00 lastmod: 2020-03-04T15:58:26+08:00 draft: true author: '' authorLink: '' description: '' license: '' images: [] tags: [] categories: [] featuredImage: '' featuredImagePreview: '' hiddenFromHomePage: false hiddenFromSearch: false twemoji: false lightgallery: true ruby: true fraction: true fontawesome: true linkToMarkdown: true rssFullText: false toc: enable: true auto: true code: copy: true maxShownLines: 50 math: enable: false # ... mapbox: # ... share: enable: true # ... comment: enable: true # ... library: css: # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" js: # someJS = \"some.js\" # 位于 \"assets/\" # 或者 # someJS = \"https://cdn.example.com/some.js\" seo: images: [] # ... --- title: 文章标题. subtitle: 文章副标题. date: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 date 字段获取的, 但是也可以在 网站配置 中设置. lastmod: 上次修改内容的日期时间. draft: 如果设为 true, 除非 hugo 命令使用了 --buildDrafts/-D 参数, 这篇文章不会被渲染. author: 文章作者. authorLink: 文章作者的链接. description: 文章内容的描述. license: 这篇文章特殊的许可. images: 页面图片, 用于 Open Graph 和 Twitter Cards. tags: 文章的标签. categories: 文章所属的类别. featuredImage: 文章的特色图片. featuredImagePreview: 用在主页预览的文章特色图片. hiddenFromHomePage: 如果设为 true, 这篇文章将不会显示在主页上. hiddenFromSearch: 如果设为 true, 这篇文章将不会显示在搜索结果中. twemoji: 如果设为 true, 这篇文章会使用 twemoji. lightgallery: 如果设为 true, 文章中的图片将可以按照画廊形式呈现. ruby: 如果设为 true, 这篇文章会使用 上标注释扩展语法. fraction: 如果设为 true, 这篇文章会使用 分数扩展语法. fontawesome: 如果设为 true, 这篇文章会使用 Font Awesome 扩展语法. linkToMarkdown: 如果设为 true, 内容的页脚将显示指向原始 Markdown 文件的链接. rssFullText: 如果设为 true, 在 RSS 中将会显示全文内容. toc: 和 网站配置 中的 params.page.toc 部分相同. code: 和 网站配置 中的 params.page.code 部分相同. math: 和 网站配置 中的 params.page.math 部分相同. mapbox: 和 网站配置 中的 params.page.mapbox 部分相同. share: 和 网站配置 中的 params.page.share 部分相同. comment: 和 网站配置 中的 params.page.comment 部分相同. library: 和 网站配置 中的 params.page.library 部分相同. seo: 和 网站配置 中的 params.page.seo 部分相同. 技巧 featuredImage 和 featuredImagePreview 支持本地资源引用的完整用法. 如果带有在前置参数中设置了 name: featured-image 或 name: featured-image-preview 属性的页面资源, 没有必要在设置 featuredImage 或 featuredImagePreview: resources: - name: featured-image src: featured-image.jpg - name: featured-image-preview src: featured-image-preview.jpg ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:2:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"3 内容摘要 LoveIt 主题使用内容摘要在主页中显示大致文章信息。Hugo 支持生成文章的摘要. 文章摘要预览 ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:3:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"自动摘要拆分 默认情况下, Hugo 自动将内容的前 70 个单词作为摘要. 你可以通过在 网站配置 中设置 summaryLength 来自定义摘要长度. 如果您要使用 CJK中文/日语/韩语 语言创建内容, 并且想使用 Hugo 的自动摘要拆分功能，请在 网站配置 中将 hasCJKLanguage 设置为 true. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:3:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"手动摘要拆分 另外, 你也可以添加 \u003c!--more--\u003e 摘要分割符来拆分文章生成摘要. 摘要分隔符之前的内容将用作该文章的摘要. 注意 请小心输入\u003c!--more--\u003e ; 即全部为小写且没有空格. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:3:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"前置参数摘要 你可能希望摘要不是文章开头的文字. 在这种情况下, 你可以在文章前置参数的 summary 变量中设置单独的摘要. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:3:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"使用文章描述作为摘要 你可能希望将文章前置参数中的 description 变量的内容作为摘要. 你仍然需要在文章开头添加 \u003c!--more--\u003e 摘要分割符. 将摘要分隔符之前的内容保留为空. 然后 LoveIt 主题会将你的文章描述作为摘要. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:3:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"摘要选择的优先级顺序 由于可以通过多种方式指定摘要, 因此了解顺序很有用. 如下: 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 但分隔符之前没有内容, 则使用描述作为摘要. 如果文章中有 \u003c!--more--\u003e 摘要分隔符, 则将按照手动摘要拆分的方法获得摘要. 如果文章前置参数中有摘要变量, 那么将以该值作为摘要. 按照自动摘要拆分方法. 注意 不建议在摘要内容中包含富文本块元素, 这会导致渲染错误. 例如代码块, 图片, 表格等. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:3:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"4 Markdown 基本语法 这部分内容在 Markdown 基本语法页面 中介绍. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:4:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"5 Markdown 扩展语法 LoveIt 主题提供了一些扩展的语法便于你撰写文章. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:5:0","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"Emoji 支持 这部分内容在 Emoji 支持页面 中介绍. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:5:1","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"数学公式 LoveIt 基于 $\\KaTeX$ 提供数学公式的支持. 在你的 网站配置 中的 [params.math] 下面设置属性 enable = true, 并在文章的前置参数中设置属性 math: true来启用数学公式的自动渲染. $\\KaTeX$ 根据 特定的分隔符 来自动渲染公式. 技巧 有一份 $\\KaTeX$ 中支持的 $\\TeX$ 函数 清单. 注意 由于 Hugo 在渲染 Markdown 文档时会根据 _/*/\u003e\u003e 之类的语法生成 HTML 文档, 并且有些转义字符形式的文本内容 (如 \\(/\\)/\\[/\\]/\\\\) 会自动进行转义处理, 因此需要对这些地方进行额外的转义字符表达来实现自动渲染: _ -\u003e \\_ * -\u003e \\* \u003e\u003e -\u003e \\\u003e\u003e \\( -\u003e \\\\( \\) -\u003e \\\\) \\[ -\u003e \\\\[ \\] -\u003e \\\\] \\\\ -\u003e \\\\\\\\ LoveIt 主题支持 raw shortcode 以避免这些转义字符, 它可以帮助您编写原始数学公式内容. 一个 raw 示例: 行内公式: 公式块: 呈现的输出效果如下: 行内公式: 公式块: 行内公式 默认的行内公式分割符有: $ ... $ \\( ... \\) (转义的: \\\\( ... \\\\)) 例如: $c = \\pm\\sqrt{a^2 + b^2}$ 和 \\\\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\\\) 呈现的输出效果如下: $c = \\pm\\sqrt{a^2 + b^2}$ 和 \\(f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi\\) 公式块 默认的公式块分割符有: $$ ... $$ \\[ ... \\] (转义的: \\\\[ ... \\\\]) \\begin{equation} ... \\end{equation} (不编号的: \\begin{equation*} ... \\end{equation*}) \\begin{align} ... \\end{align} (不编号的: \\begin{align*} ... \\end{align*}) \\begin{alignat} ... \\end{alignat} (不编号的: \\begin{alignat*} ... \\end{alignat*}) \\begin{gather} ... \\end{gather} (不编号的: \\begin{gather*} ... \\end{gather*}) \\begin{CD} ... \\end{CD} 例如: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\\\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\\\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum_{i} \\mathbf{E}\\_{i}=\\mathbf{E}\\_{1}+\\mathbf{E}\\_{2}+\\mathbf{E}_{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\\\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\\\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\\\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\\\u003e\u003e B \\\\\\\\ @VbVV @AAcA \\\\\\\\ C @= D \\end{CD} 呈现的输出效果如下: $$ c = \\pm\\sqrt{a^2 + b^2} $$ \\[ f(x)=\\int_{-\\infty}^{\\infty} \\hat{f}(\\xi) e^{2 \\pi i \\xi x} d \\xi \\] \\begin{equation*} \\rho \\frac{\\mathrm{D} \\mathbf{v}}{\\mathrm{D} t}=\\nabla \\cdot \\mathbb{P}+\\rho \\mathbf{f} \\end{equation*} \\begin{equation} \\mathbf{E}=\\sum*{i} \\mathbf{E}_{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}*{3}+\\cdots \\end{equation} \\begin{align} a\u0026=b+c \\\\ d+e\u0026=f \\end{align} \\begin{alignat}{2} 10\u0026x+\u00263\u0026y = 2 \\\\ 3\u0026x+\u002613\u0026y = 4 \\end{alignat} \\begin{gather} a=b \\\\ e=b+c \\end{gather} \\begin{CD} A @\u003ea\u003e\u003e B \\\\ @VbVV @AAcA \\\\ C @= D \\end{CD} 技巧 你可以在 网站配置 中自定义行内公式和公式块的分割符. Copy-tex Copy-tex 是一个 $\\KaTeX$ 的插件. 通过这个扩展, 在选择并复制 $\\KaTeX$ 渲染的公式时, 会将其 $\\LaTeX$ 源代码复制到剪贴板. 在你的 网站配置 中的 [params.math] 下面设置属性 copyTex = true 来启用 Copy-tex. 选择并复制上一节中渲染的公式, 可以发现复制的内容为 $\\LaTeX$ 源代码. mhchem mhchem 是一个 $\\KaTeX$ 的插件. 通过这个扩展, 你可以在文章中轻松编写漂亮的化学方程式. 在你的 网站配置 中的 [params.math] 下面设置属性 mhchem = true 来启用 mhchem. $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ 呈现的输出效果如下: $$ \\ce{CO2 + C -\u003e 2 CO} $$ $$ \\ce{Hg^2+ -\u003e[I-] HgI2 -\u003e[I-] [Hg^{II}I4]^2-} $$ ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:5:2","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"字符注音或者注释 LoveIt 主题支持一种 字符注音或者注释 Markdown 扩展语法: [Hugo]^(一个开源的静态网站生成工具) 呈现的输出效果如下: Hugo一个开源的静态网站生成工具 ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:5:3","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"分数 LoveIt 主题支持一种 分数 Markdown 扩展语法: [浅色]/[深色] [99]/[100] 呈现的输出效果如下: 浅色/深色 90/100 ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:5:4","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"Font Awesome LoveIt 主题使用 Font Awesome 作为图标库. 你同样可以在文章中轻松使用这些图标. 从 Font Awesome 网站 上获取所需的图标 class. 去露营啦! :(fas fa-campground fa-fw): 很快就回来. 真开心! :(far fa-grin-tears): 呈现的输出效果如下: 去露营啦!  很快就回来. 真开心! ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:5:5","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"转义字符 在某些特殊情况下 (编写这个主题文档时 ), 你的文章内容会与 Markdown 的基本或者扩展语法冲突, 并且无法避免. 转义字符语法可以帮助你渲染出想要的内容: {?X} -\u003e X 例如, 两个 : 会启用 emoji 语法. 但有时候这不是你想要的结果. 可以像这样使用转义字符语法: {?:}joy: 呈现的输出效果如下: :joy: 而不是 😂 技巧 这个方法可以间接解决一个还未解决的 Hugo 的 issue. 另一个例子是: [link{?]}(#escape-character) 呈现的输出效果如下: [link](#escape-character) 而不是 link. ","date":"2020-03-05","objectID":"/myblog/theme-documentation-content/:5:6","tags":["content","Markdown"],"title":"主题文档 - 内容","uri":"/myblog/theme-documentation-content/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁.","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. Hugo 使用 Markdown 为其简单的内容格式. 但是, Markdown 在很多方面都无法很好地支持. 你可以使用纯 HTML 来扩展可能性. 但这恰好是一个坏主意. 大家使用 Markdown, 正是因为它即使不经过渲染也可以轻松阅读. 应该尽可能避免使用 HTML 以保持内容简洁. 为了避免这种限制, Hugo 创建了 shortcodes. shortcode 是一个简单代码段, 可以生成合理的 HTML 代码, 并且符合 Markdown 的设计哲学. Hugo 附带了一组预定义的 shortcodes, 它们实现了一些非常常见的用法. 提供这些 shortcodes 是为了方便保持你的 Markdown 内容简洁. ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"1 figure figure 的文档 一个 figure 示例: {{\u003c figure src=\"/images/lighthouse.jpg\" title=\"Lighthouse (figure)\" \u003e}} 呈现的输出效果如下: Lighthouse (figure) 输出的 HTML 看起来像这样: \u003cfigure\u003e \u003cimg src=\"/images/lighthouse.jpg\" /\u003e \u003cfigcaption\u003e \u003ch4\u003eLighthouse (figure)\u003c/h4\u003e \u003c/figcaption\u003e \u003c/figure\u003e ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"2 gist gist 的文档 一个 gist 示例: {{\u003c gist spf13 7896402 \u003e}} 呈现的输出效果如下: 输出的 HTML 看起来像这样: \u003cscript type=\"application/javascript\" src=\"https://gist.github.com/spf13/7896402.js\" \u003e\u003c/script\u003e ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"3 highlight highlight 的文档 一个 highlight 示例: {{\u003c highlight html \u003e}} \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e {{\u003c /highlight \u003e}} 呈现的输出效果如下: \u003csection id=\"main\"\u003e \u003cdiv\u003e \u003ch1 id=\"title\"\u003e{{ .Title }}\u003c/h1\u003e {{ range .Pages }} {{ .Render \"summary\"}} {{ end }} \u003c/div\u003e \u003c/section\u003e ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"4 instagram instagram 的文档 Instagram’s API was deprecated since October 24th, 2020 The instagram-shortcode refers an endpoint of Instagram’s API, that’s deprecated since October 24th, 2020. Thus, no images can be fetched from this API endpoint, resulting in an error when the instagram-shortcode is used. For more information please have a look at GitHub issue #7879. ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"5 param param 的文档 一个 param 示例: {{\u003c param description \u003e}} 呈现的输出效果如下: Hugo 提供了多个内置的 Shortcodes, 以方便作者保持 Markdown 内容的整洁. ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"6 ref 和 relref ref 和 relref 的文档 ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"7 tweet tweet 的文档 一个 tweet 示例: {{\u003c tweet 917359331535966209 \u003e}} 呈现的输出效果如下: {{\u003c tweet 917359331535966209 \u003e}} ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"8 vimeo vimeo 的文档 一个 vimeo 示例: {{\u003c vimeo 146022717 \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"9 youtube youtube 的文档 一个 youtube 示例: {{\u003c youtube w7Ft2ymGmfc \u003e}} 呈现的输出效果如下: ","date":"2020-03-04","objectID":"/myblog/theme-documentation-built-in-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 内置 Shortcodes","uri":"/myblog/theme-documentation-built-in-shortcodes/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode.","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"LoveIt 主题在 Hugo 内置的 shortcode 的基础上提供多个扩展的 shortcode. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:0:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"1 style 注意 Hugo extended 版本对于 style shortcode 是必需的. style shortcode 用来在你的文章中插入自定义样式. style shortcode 有两个位置参数. 第一个参数是自定义样式的内容. 它支持  SASS 中的嵌套语法, 并且 \u0026 指代这个父元素. 第二个参数是包裹你要更改样式的内容的 HTML 标签, 默认值是 div. 一个 style 示例: {{\u003c style \"text-align:right; strong{color:#00b1ff;}\" \u003e}} This is a **right-aligned** paragraph. {{\u003c /style \u003e}} 呈现的输出效果如下: This is a right-aligned paragraph. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:1:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"2 link link shortcode 是 Markdown 链接语法 的替代. link shortcode 可以提供一些其它的功能并且可以在代码块中使用. 支持本地资源引用的完整用法. link shortcode 有以下命名参数: href [必需] (第一个位置参数) 链接的目标. content [可选] (第二个位置参数) 链接的内容, 默认值是 href 参数的值. 支持 Markdown 或者 HTML 格式. title [可选] (第三个位置参数) HTML a 标签 的 title 属性, 当悬停在链接上会显示的提示. rel [可选] HTML a 标签 的 rel 补充属性. class [可选] HTML a 标签 的 class 属性. 一个 link 示例: {{\u003c link \"https://assemble.io\" \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" \u003e}} {{\u003c link \"mailto:contact@revolunet.com\" \u003e}} 或者 {{\u003c link href=\"mailto:contact@revolunet.com\" \u003e}} {{\u003c link \"https://assemble.io\" Assemble \u003e}} 或者 {{\u003c link href=\"https://assemble.io\" content=Assemble \u003e}} 呈现的输出效果如下: https://assemble.io mailto:contact@revolunet.com Assemble 一个带有标题的 link 示例: {{\u003c link \"https://github.com/upstage/\" Upstage \"Visit Upstage!\" \u003e}} 或者 {{\u003c link href=\"https://github.com/upstage/\" content=Upstage title=\"Visit Upstage!\" \u003e}} 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:2:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"3 image image shortcode 是 figure shortcode 的替代. image shortcode 可以充分利用 lazysizes 和 lightGallery 两个依赖库. 支持本地资源引用的完整用法. image shortcode 有以下命名参数: src [必需] (第一个位置参数) 图片的 URL. alt [可选] (第二个位置参数) 图片无法显示时的替代文本, 默认值是 src 参数的值. 支持 Markdown 或者 HTML 格式. caption [可选] (第三个位置参数) 图片标题. 支持 Markdown 或者 HTML 格式. title [可选] 当悬停在图片上会显示的提示. class [可选] HTML figure 标签的 class 属性. src_s [可选] 图片缩略图的 URL, 用在画廊模式中, 默认值是 src 参数的值. src_l [可选] 高清图片的 URL, 用在画廊模式中, 默认值是 src 参数的值. height [可选] 图片的 height 属性. width [可选] 图片的 width 属性. linked [可选] 图片是否需要被链接, 默认值是 true. rel [可选] HTML a 标签 的 rel 补充属性, 仅在 linked 属性设置成 true 时有效. 一个 image 示例: {{\u003c image src=\"/images/lighthouse.jpg\" caption=\"Lighthouse (`image`)\" src_s=\"/images/lighthouse-small.jpg\" src_l=\"/images/lighthouse-large.jpg\" \u003e}} 呈现的输出效果如下: Lighthouse (image) ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:3:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"4 admonition admonition shortcode 支持 12 种 帮助你在页面中插入提示的横幅. 支持 Markdown 或者 HTML 格式. 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 admonition shortcode 有以下命名参数: type [可选] (第一个位置参数) admonition 横幅的类型, 默认值是 note. title [可选] (第二个位置参数) admonition 横幅的标题, 默认值是 type 参数的值. open [可选] (第三个位置参数) 横幅内容是否默认展开, 默认值是 true. 一个 admonition 示例: {{\u003c admonition type=tip title=\"This is a tip\" open=false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 或者 {{\u003c admonition tip \"This is a tip\" false \u003e}} 一个 **技巧** 横幅 {{\u003c /admonition \u003e}} 呈现的输出效果如下: This is a tip 一个 技巧 横幅 ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:4:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"5 mermaid mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能. 完整文档请查看页面 主题文档 - mermaid Shortcode. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:5:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"6 echarts echarts shortcode 使用 ECharts 库提供数据可视化的功能. 完整文档请查看页面 主题文档 - echarts Shortcode. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:6:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"7 mapbox mapbox shortcode 使用 Mapbox GL JS 库提供互动式地图的功能. 完整文档请查看页面 主题文档 - mapbox Shortcode. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:7:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"8 music music shortcode 基于 APlayer 和 MetingJS 库提供了一个内嵌的响应式音乐播放器. 完整文档请查看页面 主题文档 - music Shortcode. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:8:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"9 bilibili bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 完整文档请查看页面 主题文档 - bilibili Shortcode. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:9:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"10 typeit typeit shortcode 基于 TypeIt 库提供了打字动画. 完整文档请查看页面 主题文档 - typeit Shortcode. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:10:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"11 script script shortcode 用来在你的文章中插入  Javascript 脚本. 注意 脚本内容可以保证在所有的第三方库加载之后按顺序执行. 所以你可以自由地使用第三方库. 一个 script 示例: {{\u003c script \u003e}} console.log('Hello LoveIt!'); {{\u003c /script \u003e}} 你可以在开发者工具的控制台中看到输出. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:11:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"12 raw raw shortcode 用来在你的文章中插入原始  HTML 内容. 一个 raw 示例: 行内公式: {{\u003c raw \u003e}}\\(\\mathbf{E}=\\sum*{i} \\mathbf{E}*{i}=\\mathbf{E}_{1}+\\mathbf{E}_{2}+\\mathbf{E}\\_{3}+\\cdots\\){{\u003c /raw \u003e}} 公式块: {{\u003c raw \u003e}} \\[ a=b+c \\\\ d+e=f \\] {{\u003c /raw \u003e}} 原始的带有 Markdown 语法的内容: {{\u003c raw \u003e}}**Hello**{{\u003c /raw \u003e}} 呈现的输出效果如下: 行内公式: 公式块: 原始的带有 Markdown 语法的内容: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:12:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"13 person person shortcode 用来在你的文章中以 h-card 的格式插入个人网站链接. person shortcode 有以下命名参数: url [必需] (第一个位置参数) URL of the personal page. name [必需] (第二个位置参数) Name of the person. text [可选] (第三个位置参数) Text to display as hover tooltip of the link. picture [可选] (第四个位置参数) A picture to use as person’s avatar. nick [可选] Nickame of the person. 一个 person 示例: {{\u003c person url=\"https://evgenykuznetsov.org\" name=\"Evgeny Kuznetsov\" nick=\"nekr0z\" text=\"author of this shortcode\" picture=\"https://evgenykuznetsov.org/img/avatar.jpg\" \u003e}} 呈现的输出效果为  Evgeny Kuznetsov (nekr0z). 一个使用通用图标的 person 示例: {{\u003c person \"https://dillonzq.com/\" Dillon \"author of the LoveIt theme\" \u003e}} 呈现的输出效果为  Dillon. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-extended-shortcodes/:13:0","tags":["shortcodes"],"title":"主题文档 - 扩展 Shortcodes","uri":"/myblog/theme-documentation-extended-shortcodes/"},{"categories":["documentation"],"content":"mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能.","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":" mermaid shortcode 使用 Mermaid 库提供绘制图表和流程图的功能. mermaid 是一个可以帮助你在文章中绘制图表和流程图的库, 类似 Markdown 的语法. 只需将你的 mermaid 代码插入 mermaid shortcode 中即可. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"流程图 一个 流程图 mermaid 示例: {{\u003c mermaid \u003e}} graph LR; A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:1:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"时序图 一个 时序图 mermaid 示例: {{\u003c mermaid \u003e}} sequenceDiagram participant Alice participant Bob Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts \u003cbr/\u003eprevail... John--\u003eAlice: Great! John-\u003eBob: How about you? Bob--\u003eJohn: Jolly good! {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:2:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"甘特图 一个 甘特图 mermaid 示例: {{\u003c mermaid \u003e}} gantt dateFormat YYYY-MM-DD title Adding GANTT diagram to mermaid excludes weekdays 2014-01-10 section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:3:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"类图 一个 类图 mermaid 示例: {{\u003c mermaid \u003e}} classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:4:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"状态图 一个 状态图 mermaid 示例: {{\u003c mermaid \u003e}} stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:5:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"Git 图 一个 Git 图 mermaid 示例: {{\u003c mermaid \u003e}} gitGraph commit commit branch develop checkout develop commit commit checkout main merge develop commit commit {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:6:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"实体关系图 一个 实体关系图 mermaid 示例: {{\u003c mermaid \u003e}} erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:7:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"用户体验旅程图 一个 用户体验旅程图 mermaid 示例: {{\u003c mermaid \u003e}} journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:8:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"饼图 一个 饼图 mermaid 示例: {{\u003c mermaid \u003e}} pie \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:9:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"依赖图 一个 依赖图 mermaid 示例: {{\u003c mermaid \u003e}} requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u003e test_req {{\u003c /mermaid \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mermaid-shortcode/:10:0","tags":["shortcodes"],"title":"主题文档 - mermaid Shortcode","uri":"/myblog/theme-documentation-mermaid-shortcode/"},{"categories":["documentation"],"content":"echarts shortcode 使用 ECharts 库提供数据可视化的功能.","date":"2020-03-03","objectID":"/myblog/theme-documentation-echarts-shortcode/","tags":["shortcodes"],"title":"主题文档 - echarts Shortcode","uri":"/myblog/theme-documentation-echarts-shortcode/"},{"categories":["documentation"],"content":"echarts shortcode 使用 ECharts 库提供数据可视化的功能. ECharts 是一个帮助你生成交互式数据可视化的库. ECharts 提供了常规的 折线图, 柱状图, 散点图, 饼图, K 线图, 用于统计的 盒形图, 用于地理数据可视化的 地图, 热力图, 线图, 用于关系数据可视化的 关系图, treemap, 旭日图, 多维数据可视化的 平行坐标, 还有用于 BI 的 漏斗图, 仪表盘, 并且支持图与图之间的混搭. 只需在 echarts shortcode 中以 JSON/YAML/TOML格式插入 ECharts 选项即可. 一个 JSON 格式的 echarts 示例: {{\u003c echarts \u003e}} { \"title\": { \"text\": \"折线统计图\", \"top\": \"2%\", \"left\": \"center\" }, \"tooltip\": { \"trigger\": \"axis\" }, \"legend\": { \"data\": [\"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\"], \"top\": \"10%\" }, \"grid\": { \"left\": \"5%\", \"right\": \"5%\", \"bottom\": \"5%\", \"top\": \"20%\", \"containLabel\": true }, \"toolbox\": { \"feature\": { \"saveAsImage\": { \"title\": \"保存为图片\" } } }, \"xAxis\": { \"type\": \"category\", \"boundaryGap\": false, \"data\": [\"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\"] }, \"yAxis\": { \"type\": \"value\" }, \"series\": [ { \"name\": \"邮件营销\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [120, 132, 101, 134, 90, 230, 210] }, { \"name\": \"联盟广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [220, 182, 191, 234, 290, 330, 310] }, { \"name\": \"视频广告\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [150, 232, 201, 154, 190, 330, 410] }, { \"name\": \"直接访问\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [320, 332, 301, 334, 390, 330, 320] }, { \"name\": \"搜索引擎\", \"type\": \"line\", \"stack\": \"总量\", \"data\": [820, 932, 901, 934, 1290, 1330, 1320] } ] } {{\u003c /echarts \u003e}} 一个 YAML 格式的 echarts 示例: {{\u003c echarts \u003e}} title: text: 折线统计图 top: 2% left: center tooltip: trigger: axis legend: data: - 邮件营销 - 联盟广告 - 视频广告 - 直接访问 - 搜索引擎 top: 10% grid: left: 5% right: 5% bottom: 5% top: 20% containLabel: true toolbox: feature: saveAsImage: title: 保存为图片 xAxis: type: category boundaryGap: false data: - 周一 - 周二 - 周三 - 周四 - 周五 - 周六 - 周日 yAxis: type: value series: - name: 邮件营销 type: line stack: 总量 data: - 120 - 132 - 101 - 134 - 90 - 230 - 210 - name: 联盟广告 type: line stack: 总量 data: - 220 - 182 - 191 - 234 - 290 - 330 - 310 - name: 视频广告 type: line stack: 总量 data: - 150 - 232 - 201 - 154 - 190 - 330 - 410 - name: 直接访问 type: line stack: 总量 data: - 320 - 332 - 301 - 334 - 390 - 330 - 320 - name: 搜索引擎 type: line stack: 总量 data: - 820 - 932 - 901 - 934 - 1290 - 1330 - 1320 {{\u003c /echarts \u003e}} 一个 TOML 格式的 echarts 示例: {{\u003c echarts \u003e}} [title] text = \"折线统计图\" top = \"2%\" left = \"center\" [tooltip] trigger = \"axis\" [legend] data = [ \"邮件营销\", \"联盟广告\", \"视频广告\", \"直接访问\", \"搜索引擎\" ] top = \"10%\" [grid] left = \"5%\" right = \"5%\" bottom = \"5%\" top = \"20%\" containLabel = true [toolbox] [toolbox.feature] [toolbox.feature.saveAsImage] title = \"保存为图片\" [xAxis] type = \"category\" boundaryGap = false data = [ \"周一\", \"周二\", \"周三\", \"周四\", \"周五\", \"周六\", \"周日\" ] [yAxis] type = \"value\" [[series]] name = \"邮件营销\" type = \"line\" stack = \"总量\" data = [ 120.0, 132.0, 101.0, 134.0, 90.0, 230.0, 210.0 ] [[series]] name = \"联盟广告\" type = \"line\" stack = \"总量\" data = [ 220.0, 182.0, 191.0, 234.0, 290.0, 330.0, 310.0 ] [[series]] name = \"视频广告\" type = \"line\" stack = \"总量\" data = [ 150.0, 232.0, 201.0, 154.0, 190.0, 330.0, 410.0 ] [[series]] name = \"直接访问\" type = \"line\" stack = \"总量\" data = [ 320.0, 332.0, 301.0, 334.0, 390.0, 330.0, 320.0 ] [[series]] name = \"搜索引擎\" type = \"line\" stack = \"总量\" data = [ 820.0, 932.0, 901.0, 934.0, 1290.0, 1330.0, 1320.0 ] {{\u003c /echarts \u003e}} 呈现的输出效果如下: echarts shortcode 还有以下命名参数: width [可选] (第一个位置参数) 数据可视化的宽度, 默认值是 100%. height [可选] (第二个位置参数) 数据可视化的高度, 默认值是 30rem. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-echarts-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - echarts Shortcode","uri":"/myblog/theme-documentation-echarts-shortcode/"},{"categories":["documentation"],"content":"mapbox shortcode 使用 Mapbox GL JS 库提供互动式地图的功能.","date":"2020-03-03","objectID":"/myblog/theme-documentation-mapbox-shortcode/","tags":["shortcodes"],"title":"主题文档 - mapbox Shortcode","uri":"/myblog/theme-documentation-mapbox-shortcode/"},{"categories":["documentation"],"content":" mapbox shortcode 使用 Mapbox GL JS 库提供互动式地图的功能. Mapbox GL JS 是一个 JavaScript 库，它使用 WebGL, 以 vector tiles 和 Mapbox styles 为来源, 将它们渲染成互动式地图. mapbox shortcode 有以下命名参数来使用 Mapbox GL JS: lng [必需] (第一个位置参数) 地图初始中心点的经度, 以度为单位. lat [必需] (第二个位置参数) 地图初始中心点的纬度, 以度为单位. zoom [可选] (第三个位置参数) 地图的初始缩放级别, 默认值是 10. marked [可选] (第四个位置参数) 是否在地图的初始中心点添加图钉, 默认值是 true. light-style [可选] (第五个位置参数) 浅色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. dark-style [可选] (第六个位置参数) 深色主题的地图样式, 默认值是前置参数或者网站配置中设置的值. navigation [可选] 是否添加 NavigationControl, 默认值是前置参数或者网站配置中设置的值. geolocate [可选] 是否添加 GeolocateControl, 默认值是前置参数或者网站配置中设置的值. scale [可选] 是否添加 ScaleControl, 默认值是前置参数或者网站配置中设置的值. fullscreen [可选] 是否添加 FullscreenControl, 默认值是前置参数或者网站配置中设置的值. width [可选] 地图的宽度, 默认值是 100%. height [可选] 地图的高度, 默认值是 20rem. 一个简单的 mapbox 示例: {{\u003c mapbox 121.485 31.233 12 \u003e}} 或者 {{\u003c mapbox lng=121.485 lat=31.233 zoom=12 \u003e}} 呈现的输出效果如下: 一个带有自定义样式的 mapbox 示例: {{\u003c mapbox -122.252 37.453 10 false \"mapbox://styles/mapbox/streets-zh-v1?optimize=true\" \u003e}} 或者 {{\u003c mapbox lng=-122.252 lat=37.453 zoom=10 marked=false light-style=\"mapbox://styles/mapbox/streets-zh-v1?optimize=true\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-mapbox-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - mapbox Shortcode","uri":"/myblog/theme-documentation-mapbox-shortcode/"},{"categories":["documentation"],"content":"music shortcode 基于 APlayer 和 MetingJS 库提供了一个内嵌的响应式音乐播放器.","date":"2020-03-03","objectID":"/myblog/theme-documentation-music-shortcode/","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"/myblog/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"music shortcode 基于 APlayer 和 MetingJS 库提供了一个内嵌的响应式音乐播放器. 有三种方式使用 music shortcode. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-music-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"/myblog/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"1 自定义音乐 URL 支持本地资源引用的完整用法. music shortcode 有以下命名参数来使用自定义音乐 URL: server [必需] 音乐的链接. type [可选] 音乐的名称. artist [可选] 音乐的创作者. cover [可选] 音乐的封面链接. 一个使用自定义音乐 URL 的 music 示例: {{\u003c music url=\"/music/Wavelength.mp3\" name=Wavelength artist=oldmanyoung cover=\"/images/Wavelength.jpg\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-music-shortcode/:1:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"/myblog/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"2 音乐平台 URL 的自动识别 music shortcode 有一个命名参数来使用音乐平台 URL 的自动识别: auto [必需]] (第一个位置参数) 用来自动识别的音乐平台 URL, 支持 netease, tencent 和 xiami 平台. 一个使用音乐平台 URL 的自动识别的 music 示例: {{\u003c music auto=\"https://music.163.com/#/playlist?id=60198\" \u003e}} 或者 {{\u003c music \"https://music.163.com/#/playlist?id=60198\" \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-music-shortcode/:2:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"/myblog/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"3 自定义音乐平台, 类型和 ID music shortcode 有以下命名参数来使用自定义音乐平台: server [必需] (第一个位置参数) [netease, tencent, kugou, xiami, baidu] 音乐平台. type [必需] (第二个位置参数) [song, playlist, album, search, artist] 音乐类型. id [必需] (第三个位置参数) 歌曲 ID, 或者播放列表 ID, 或者专辑 ID, 或者搜索关键词, 或者创作者 ID. 一个使用自定义音乐平台的 music 示例: {{\u003c music server=\"netease\" type=\"song\" id=\"1868553\" \u003e}} 或者 {{\u003c music netease song 1868553 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-music-shortcode/:3:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"/myblog/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"4 其它参数 music shortcode 有一些可以应用于以上三种方式的其它命名参数: theme [可选] 音乐播放器的主题色, 默认值是 #448aff. fixed [可选] 是否开启固定模式, 默认值是 false. mini [可选] 是否开启迷你模式, 默认值是 false. autoplay [可选] 是否自动播放音乐, 默认值是 false. volume [可选] 第一次打开播放器时的默认音量, 会被保存在浏览器缓存中, 默认值是 0.7. mutex [可选] 是否自动暂停其它播放器, 默认值是 true. music shortcode 还有一些只适用于音乐列表方式的其它命名参数: loop [可选] [all, one, none] 音乐列表的循环模式, 默认值是 none. order [可选] [list, random] 音乐列表的播放顺序, 默认值是 list. list-folded [可选] 初次打开的时候音乐列表是否折叠, 默认值是 false. list-max-height [可选] 音乐列表的最大高度, 默认值是 340px. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-music-shortcode/:4:0","tags":["shortcodes"],"title":"主题文档 - music Shortcode","uri":"/myblog/theme-documentation-music-shortcode/"},{"categories":["documentation"],"content":"bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器.","date":"2020-03-03","objectID":"/myblog/theme-documentation-bilibili-shortcode/","tags":["shortcodes"],"title":"主题文档 - bilibili Shortcode","uri":"/myblog/theme-documentation-bilibili-shortcode/"},{"categories":["documentation"],"content":" bilibili shortcode 提供了一个内嵌的用来播放 bilibili 视频的响应式播放器. 如果视频只有一个部分, 则仅需要视频的 BV id, 例如: https://www.bilibili.com/video/BV1Sx411T7QQ 一个 bilibili 示例: {{\u003c bilibili BV1Sx411T7QQ \u003e}} 或者 {{\u003c bilibili id=BV1Sx411T7QQ \u003e}} 呈现的输出效果如下: 如果视频包含多个部分, 则除了视频的 BV id 之外, 还需要 p, 默认值为 1, 例如: https://www.bilibili.com/video/BV1TJ411C7An?p=3 一个带有 p 参数的 bilibili 示例: {{\u003c bilibili BV1TJ411C7An 3 \u003e}} 或者 {{\u003c bilibili id=BV1TJ411C7An p=3 \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-bilibili-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - bilibili Shortcode","uri":"/myblog/theme-documentation-bilibili-shortcode/"},{"categories":["documentation"],"content":"typeit shortcode 基于 TypeIt 库提供了打字动画.","date":"2020-03-03","objectID":"/myblog/theme-documentation-typeit-shortcode/","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"/myblog/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"typeit shortcode 基于 TypeIt 库提供了打字动画. 只需将你需要打字动画的内容插入 typeit shortcode 中即可. ","date":"2020-03-03","objectID":"/myblog/theme-documentation-typeit-shortcode/:0:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"/myblog/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"1 简单内容 允许使用 Markdown 格式的简单内容, 并且 不包含 富文本的块内容, 例如图像等等… 一个 typeit 示例: {{\u003c typeit \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: 另外, 你也可以自定义 HTML 标签. 一个带有 h4 标签的 typeit 示例: {{\u003c typeit tag=h4 \u003e}} 这一个带有基于 [TypeIt](https://typeitjs.com/) 的 **打字动画** 的 *段落*... {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-typeit-shortcode/:1:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"/myblog/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"2 代码内容 代码内容也是允许的, 并且通过使用参数 code 指定语言类型可以实习语法高亮. 一个带有 code 参数的 typeit 示例: {{\u003c typeit code=java \u003e}} public class HelloWorld { public static void main(String []args) { System.out.println(\"Hello World\"); } } {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-typeit-shortcode/:2:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"/myblog/theme-documentation-typeit-shortcode/"},{"categories":["documentation"],"content":"3 分组内容 默认情况下, 所有打字动画都是同时开始的. 但是有时你可能需要按顺序开始一组 typeit 内容的打字动画. 一组具有相同 group 参数值的 typeit 内容将按顺序开始打字动画. 一个带有 group 参数的 typeit 示例: {{\u003c typeit group=paragraph \u003e}} **首先**, 这个段落开始 {{\u003c /typeit \u003e}} {{\u003c typeit group=paragraph \u003e}} **然后**, 这个段落开始 {{\u003c /typeit \u003e}} 呈现的输出效果如下: ","date":"2020-03-03","objectID":"/myblog/theme-documentation-typeit-shortcode/:3:0","tags":["shortcodes"],"title":"主题文档 - typeit Shortcode","uri":"/myblog/theme-documentation-typeit-shortcode/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例. 注意 这篇文章借鉴了一篇很棒的来自 Grav 的文章. 如果你想了解 Loveit 主题的扩展 Markdown 语法, 请阅读扩展 Markdown 语法页面. 事实上, 编写 Web 内容很麻烦. WYSIWYG所见即所得 编辑器帮助减轻了这一任务. 但通常会导致代码太糟, 或更糟糕的是, 网页也会很丑. 没有通常伴随的所有复杂和丑陋的问题, Markdown 是一种更好的生成 HTML 内容的方式. 一些主要好处是: Markdown 简单易学, 几乎没有多余的字符, 因此编写内容也更快. 用 Markdown 书写时出错的机会更少. 可以产生有效的 XHTML 输出. 将内容和视觉显示保持分开, 这样就不会打乱网站的外观. 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容. Markdown 使用起来很有趣! John Gruber, Markdown 的作者如是说: Markdown 格式的首要设计目标是更具可读性. 最初的想法是 Markdown 格式的文档应当以纯文本形式发布, 而不会看起来像被标签或格式说明所标记. 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响, 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式. – John Gruber 话不多说, 我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式! 技巧  将此页保存为书签，以备将来参考! ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:0:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样: \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中: ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样: \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:1:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释: ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:2:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的. 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签: ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下: ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:3:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落, 纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹. 如下段落: Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样: \u003cp\u003e Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. \u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:4:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 (带有一个类), 则可以简单地像这样使用: Markdown 格式的段落. \u003cdiv class=\"class\"\u003e这是 \u003cb\u003eHTML\u003c/b\u003e\u003c/div\u003e Markdown 格式的段落. ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:5:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:6:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段. 以下文本片段会被 渲染为粗体. **渲染为粗体** **渲染为粗体** 输出的 HTML 看起来像这样: \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:6:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段. 以下文本片段被 渲染为斜体. _渲染为斜体_ _渲染为斜体_ 输出的 HTML 看起来像这样: \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:6:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线. ~~这段文本带有删除线.~~ 呈现的输出效果如下: 这段文本带有删除线. 输出的 HTML 看起来像这样: \u003cdel\u003e这段文本带有删除线.\u003c/del\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:6:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗, 斜体, 和删除线可以 组合使用. **_加粗和斜体_** ~~**删除线和加粗**~~ ~~_删除线和斜体_~~ ~~**_加粗, 斜体和删除线_**~~ 呈现的输出效果如下: 加粗和斜体 删除线和加粗 删除线和斜体 加粗, 斜体和删除线 输出的 HTML 看起来像这样: \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel \u003e\u003cem\u003e\u003cstrong\u003e加粗, 斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del \u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:6:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块. 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样: \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套: \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. \u003e Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e \u003e \u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor \u003e \u003e odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下: Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:7:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:8:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表, 其中项的顺序没有明显关系. 你可以使用以下任何符号来表示无序列表中的项: - 一项内容 * 一项内容 - 一项内容 例如: - Lorem ipsum dolor sit amet - Consectetur adipiscing elit - Integer molestie lorem at massa - Facilisis in pretium nisl aliquet - Nulla volutpat aliquam velit - Phasellus iaculis neque - Purus sodales ultricies - Vestibulum laoreet porttitor sem - Ac tristique libero volutpat at - Faucibus porta lacus fringilla vel - Aenean sit amet erat nunc - Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003e Nulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:8:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表, 其中项的顺序确实很重要. 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样: \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号. 例如: 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下: Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:8:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表. 要创建任务列表, 请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ]). 要选择一个复选框，请在方括号之间添加 x ([x]). - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下: Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:8:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:9:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段. 在这个例子中, `\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**. 呈现的输出效果如下: 在这个例子中, \u003csection\u003e\u003c/section\u003e 会被包裹成 代码. 输出的 HTML 看起来像这样: \u003cp\u003e 在这个例子中, \u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e. \u003c/p\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:9:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如: // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下: // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样: \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:9:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块. ```markdown Sample text here... ``` 输出的 HTML 看起来像这样: \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:9:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮. 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名, ```js, 语法高亮显示将自动应用于渲染的 HTML 中. 例如, 在以下 JavaScript 代码中应用语法高亮: ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下: grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息, 包括语法高亮的 shortcode. ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:9:4","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线, 并在标题下添加一行破折号 (也由竖线分隔) 来创建表格. 注意, 竖线不需要垂直对齐. | Option | Description | | ------ | ------------------------------------------------------------------------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样: \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003e path to data files to supply the data that will be passed into templates. \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003e engine to be used for processing templates. Handlebars is the default. \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐. 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中. | Option | Description | | :----: | ------------------------------------------------------------------------: | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:10:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:11:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 (将鼠标悬停在链接上，没有提示): https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样: \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:11:1","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ 'Visit Upstage!') 呈现的输出效果如下 (将鼠标悬停在链接上，会有一行提示): Upstage 输出的 HTML 看起来像这样: \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:11:2","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点. 例如, 每个章节: ## Table of Contents - [Chapter 1](#chapter-1) - [Chapter 2](#chapter-2) - [Chapter 3](#chapter-3) 将跳转到这些部分: ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的. 因为它们并不引人注目, 所以它们通常被放在同一行了. ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:11:3","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考, 而不会使文档正文混乱. 当你创建脚注时, 会在添加脚注引用的位置出现带有链接的上标编号. 读者可以单击链接以跳至页面底部的脚注内容. 要创建脚注引用, 请在方括号中添加插入符号和标识符 ([^1]). 标识符可以是数字或单词, 但不能包含空格或制表符. 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中, 脚注按顺序编号. 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注). 你不一定要在文档末尾添加脚注. 可以将它们放在除列表, 引用和表格等元素之外的任何位置. 这是一个数字脚注[^1]. 这是一个带标签的脚注[^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注1. 这是一个带标签的脚注2 ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:12:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似, 但包含一个在前面的感叹号. ![Minion](https://octodex.github.com/images/minion.png) 或者: ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg 'The Stormtroopocat') The Stormtroopocat 像链接一样, 图片也具有脚注样式的语法: ![Alt text][id] The Dojocat 稍后在文档中提供参考内容, 用来定义 URL 的位置: [id]: https://octodex.github.com/images/dojocat.jpg 'The Dojocat' 技巧 LoveIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/myblog/basic-markdown-syntax/:13:0","tags":["Markdown","HTML"],"title":"Markdown 基本语法","uri":"/myblog/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"Hugo 和 LoveIt 中的 Emoji 的用法指南.","date":"2019-10-01","objectID":"/myblog/emoji-support/","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"Emoji 可以通过多种方式在 Hugo 项目中启用. emojify 方法可以直接在模板中调用, 或者使用行内 Shortcodes. 要全局使用 emoji, 需要在你的网站配置中设置 enableEmoji 为 true, 然后你就可以直接在文章中输入 emoji 的代码. 它们以冒号开头和结尾，并且包含 emoji 的 代码: 去露营啦! :tent: 很快就回来. 真开心! :joy: 呈现的输出效果如下: 去露营啦! ⛺ 很快就回来. 真开心! 😂 以下符号清单是 emoji 代码的非常有用的参考. ","date":"2019-10-01","objectID":"/myblog/emoji-support/:0:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"表情与情感 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"笑脸表情 图标 代码 图标 代码 😀 grinning 😃 smiley 😄 smile 😁 grin 😆 laughing satisfied 😅 sweat_smile 🤣 rofl 😂 joy 🙂 slightly_smiling_face 🙃 upside_down_face 😉 wink 😊 blush 😇 innocent ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:1","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"爱意表情 图标 代码 图标 代码 😍 heart_eyes 😘 kissing_heart 😗 kissing ☺️ relaxed 😚 kissing_closed_eyes 😙 kissing_smiling_eyes ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:2","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"吐舌头表情 图标 代码 图标 代码 😋 yum 😛 stuck_out_tongue 😜 stuck_out_tongue_winking_eye 😝 stuck_out_tongue_closed_eyes 🤑 money_mouth_face ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:3","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"带手的表情 图标 代码 图标 代码 🤗 hugs 🤔 thinking ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:4","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"中性表情 图标 代码 图标 代码 🤐 zipper_mouth_face 😐 neutral_face 😑 expressionless 😶 no_mouth 😏 smirk 😒 unamused 🙄 roll_eyes 😬 grimacing 🤥 lying_face ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:5","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"困倦的表情 图标 代码 图标 代码 😌 relieved 😔 pensive 😪 sleepy 🤤 drooling_face 😴 sleeping ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:6","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"不适的表情 图标 代码 图标 代码 😷 mask 🤒 face_with_thermometer 🤕 face_with_head_bandage 🤢 nauseated_face 🤧 sneezing_face 😵 dizzy_face ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:7","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"戴帽子的表情 图标 代码 图标 代码 🤠 cowboy_hat_face ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:8","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"戴眼镜的表情 图标 代码 图标 代码 😎 sunglasses 🤓 nerd_face ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:9","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"担心的表情 图标 代码 图标 代码 😕 confused 😟 worried 🙁 slightly_frowning_face ☹ frowning_face 😮 open_mouth 😯 hushed 😲 astonished 😳 flushed 😦 frowning 😧 anguished 😨 fearful 😰 cold_sweat 😥 disappointed_relieved 😢 cry 😭 sob 😱 scream 😖 confounded 😣 persevere 😞 disappointed 😓 sweat 😩 weary 😫 tired_face ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:10","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"否定的表情 图标 代码 图标 代码 😤 triumph 😡 pout rage 😠 angry 😈 smiling_imp 👿 imp 💀 skull ☠️ skull_and_crossbones ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:11","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"特殊打扮的表情 图标 代码 图标 代码 💩 hankey poop shit 🤡 clown_face 👹 japanese_ogre 👺 japanese_goblin 👻 ghost 👽 alien 👾 space_invader 🤖 robot ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:12","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"猫脸表情 图标 代码 图标 代码 😺 smiley_cat 😸 smile_cat 😹 joy_cat 😻 heart_eyes_cat 😼 smirk_cat 😽 kissing_cat 🙀 scream_cat 😿 crying_cat_face 😾 pouting_cat ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:13","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"猴脸表情 图标 代码 图标 代码 🙈 see_no_evil 🙉 hear_no_evil 🙊 speak_no_evil ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:14","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"情感 图标 代码 图标 代码 💋 kiss 💌 love_letter 💘 cupid 💝 gift_heart 💖 sparkling_heart 💗 heartpulse 💓 heartbeat 💞 revolving_hearts 💕 two_hearts 💟 heart_decoration ❣️ heavy_heart_exclamation 💔 broken_heart ❤️ heart 💛 yellow_heart 💚 green_heart 💙 blue_heart 💜 purple_heart 🖤 black_heart 💯 100 💢 anger 💥 boom collision 💫 dizzy 💦 sweat_drops 💨 dash 🕳️ hole 💣 bomb 💬 speech_balloon 👁️‍🗨️ eye_speech_bubble 🗯️ right_anger_bubble 💭 thought_balloon 💤 zzz ","date":"2019-10-01","objectID":"/myblog/emoji-support/:1:15","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"人与身体 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"张开手掌的手势 图标 代码 图标 代码 👋 wave 🤚 raised_back_of_hand 🖐️ raised_hand_with_fingers_splayed ✋ hand raised_hand 🖖 vulcan_salute ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:1","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"部分手指的手势 图标 代码 图标 代码 👌 ok_hand ✌️ v 🤞 crossed_fingers 🤘 metal 🤙 call_me_hand ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:2","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"一根手指的手势 图标 代码 图标 代码 👈 point_left 👉 point_right 👆 point_up_2 🖕 fu middle_finger 👇 point_down ☝️ point_up ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:3","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"握紧的手势 图标 代码 图标 代码 👍 +1 thumbsup 👎 -1 thumbsdown ✊ fist fist_raised 👊 facepunch fist_oncoming punch 🤛 fist_left 🤜 fist_right ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:4","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"两只手 图标 代码 图标 代码 👏 clap 🙌 raised_hands 👐 open_hands 🤝 handshake 🙏 pray ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:5","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"握住东西的手势 图标 代码 图标 代码 ✍️ writing_hand 💅 nail_care 🤳 selfie ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:6","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"身体部位 图标 代码 图标 代码 💪 muscle 👂 ear 👃 nose 👀 eyes 👁️ eye 👅 tongue 👄 lips ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:7","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"人 图标 代码 图标 代码 👶 baby 👦 boy 👧 girl :blonde_man: blonde_man person_with_blond_hair 👨 man 👩 woman 👱‍♀️ blonde_woman 👴 older_man 👵 older_woman ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:8","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"身体动作 图标 代码 图标 代码 🙍‍♀️ frowning_woman person_frowning 🙍‍♂️ frowning_man 🙎‍♀️ person_with_pouting_face pouting_woman 🙎‍♂️ pouting_man 🙅‍♀️ ng_woman no_good no_good_woman 🙅‍♂️ ng_man no_good_man 🙆‍♀️ ok_woman 🙆‍♂️ ok_man 💁‍♀️ information_desk_person sassy_woman tipping_hand_woman 💁‍♂️ sassy_man tipping_hand_man 🙋‍♀️ raising_hand raising_hand_woman 🙋‍♂️ raising_hand_man 🙇 bow bowing_man 🙇‍♀️ bowing_woman 🤦‍♂️ man_facepalming 🤦‍♀️ woman_facepalming 🤷‍♂️ man_shrugging 🤷‍♀️ woman_shrugging ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:9","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"人物角色 图标 代码 图标 代码 👨‍⚕️ man_health_worker 👩‍⚕️ woman_health_worker 👨‍🎓 man_student 👩‍🎓 woman_student 👨‍🏫 man_teacher 👩‍🏫 woman_teacher 👨‍⚖️ man_judge 👩‍⚖️ woman_judge 👨‍🌾 man_farmer 👩‍🌾 woman_farmer 👨‍🍳 man_cook 👩‍🍳 woman_cook 👨‍🔧 man_mechanic 👩‍🔧 woman_mechanic 👨‍🏭 man_factory_worker 👩‍🏭 woman_factory_worker 👨‍💼 man_office_worker 👩‍💼 woman_office_worker 👨‍🔬 man_scientist 👩‍🔬 woman_scientist 👨‍💻 man_technologist 👩‍💻 woman_technologist 👨‍🎤 man_singer 👩‍🎤 woman_singer 👨‍🎨 man_artist 👩‍🎨 woman_artist 👨‍✈️ man_pilot 👩‍✈️ woman_pilot 👨‍🚀 man_astronaut 👩‍🚀 woman_astronaut 👨‍🚒 man_firefighter 👩‍🚒 woman_firefighter 👮‍♂️ cop policeman 👮‍♀️ policewoman 🕵 detective male_detective 🕵️‍♀️ female_detective 💂‍♂️ guardsman 💂‍♀️ guardswoman 👷‍♂️ construction_worker construction_worker_man 👷‍♀️ construction_worker_woman 🤴 prince 👸 princess 👳‍♂️ man_with_turban 👳‍♀️ woman_with_turban 👲 man_with_gua_pi_mao 🤵‍♂️ man_in_tuxedo 👰 bride_with_veil 🤰 pregnant_woman ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:10","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"幻想的人物 图标 代码 图标 代码 👼 angel 🎅 santa 🤶 mrs_claus ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:11","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"人物活动 图标 代码 图标 代码 💆‍♀️ massage massage_woman 💆‍♂️ massage_man 💇‍♀️ haircut haircut_woman 💇‍♂️ haircut_man 🚶‍♂️ walking walking_man 🚶‍♀️ walking_woman 🏃‍♂️ runner running running_man 🏃‍♀️ running_woman 💃 dancer 🕺 man_dancing 🕴️ business_suit_levitating 👯‍♀️ dancers dancing_women 👯‍♂️ dancing_men ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:12","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"体育 图标 代码 图标 代码 🤺 person_fencing 🏇 horse_racing ⛷️ skier 🏂 snowboarder 🏌️‍♂️ golfing_man 🏌️‍♀️ golfing_woman 🏄‍♂️ surfer surfing_man 🏄‍♀️ surfing_woman 🚣‍♂️ rowboat rowing_man 🚣‍♀️ rowing_woman 🏊‍♂️ swimmer swimming_man 🏊‍♀️ swimming_woman ⛹️‍♂️ basketball_man ⛹️‍♀️ basketball_woman 🏋️‍♂️ weight_lifting_man 🏋️‍♀️ weight_lifting_woman 🚴‍♂️ bicyclist biking_man 🚴‍♀️ biking_woman 🚵‍♂️ mountain_bicyclist mountain_biking_man 🚵‍♀️ mountain_biking_woman 🤸‍♂️ man_cartwheeling 🤸‍♀️ woman_cartwheeling 🤼‍♂️ men_wrestling 🤼‍♀️ women_wrestling 🤽‍♂️ man_playing_water_polo 🤽‍♀️ woman_playing_water_polo 🤾‍♂️ man_playing_handball 🤾‍♀️ woman_playing_handball 🤹‍♂️ man_juggling 🤹‍♀️ woman_juggling ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:13","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"休息 图标 代码 图标 代码 🛀 bath 🛌 sleeping_bed ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:14","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"家庭 图标 代码 图标 代码 👭 two_women_holding_hands 👫 couple 👬 two_men_holding_hands 👩‍❤️‍💋‍👨 couplekiss_man_woman 👨‍❤️‍💋‍👨 couplekiss_man_man 👩‍❤️‍💋‍👩 couplekiss_woman_woman 💑 couple_with_heart couple_with_heart_woman_man 👨‍❤️‍👨 couple_with_heart_man_man 👩‍❤️‍👩 couple_with_heart_woman_woman 👨‍👩‍👦 family family_man_woman_boy 👨‍👩‍👧 family_man_woman_girl 👨‍👩‍👧‍👦 family_man_woman_girl_boy 👨‍👩‍👦‍👦 family_man_woman_boy_boy 👨‍👩‍👧‍👧 family_man_woman_girl_girl 👨‍👨‍👦 family_man_man_boy 👨‍👨‍👧 family_man_man_girl 👨‍👨‍👧‍👦 family_man_man_girl_boy 👨‍👨‍👦‍👦 family_man_man_boy_boy 👨‍👨‍👧‍👧 family_man_man_girl_girl 👩‍👩‍👦 family_woman_woman_boy 👩‍👩‍👧 family_woman_woman_girl 👩‍👩‍👧‍👦 family_woman_woman_girl_boy 👩‍👩‍👦‍👦 family_woman_woman_boy_boy 👩‍👩‍👧‍👧 family_woman_woman_girl_girl 👨‍👦 family_man_boy 👨‍👦‍👦 family_man_boy_boy 👨‍👧 family_man_girl 👨‍👧‍👦 family_man_girl_boy 👨‍👧‍👧 family_man_girl_girl 👩‍👦 family_woman_boy 👩‍👦‍👦 family_woman_boy_boy 👩‍👧 family_woman_girl 👩‍👧‍👦 family_woman_girl_boy 👩‍👧‍👧 family_woman_girl_girl ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:15","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"人物符号 图标 代码 图标 代码 🗣 speaking_head 👤 bust_in_silhouette 👥 busts_in_silhouette 👣 footprints ","date":"2019-10-01","objectID":"/myblog/emoji-support/:2:16","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"动物与自然 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:3:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"哺乳动物 图标 代码 图标 代码 🐵 monkey_face 🐒 monkey 🦍 gorilla 🐶 dog 🐕 dog2 🐩 poodle 🐺 wolf 🦊 fox_face 🐱 cat 🐈 cat2 🦁 lion 🐯 tiger 🐅 tiger2 🐆 leopard 🐴 horse 🐎 racehorse 🦄 unicorn 🦌 deer 🐮 cow 🐂 ox 🐃 water_buffalo 🐄 cow2 🐷 pig 🐖 pig2 🐗 boar 🐽 pig_nose 🐏 ram 🐑 sheep 🐐 goat 🐪 dromedary_camel 🐫 camel 🐘 elephant 🦏 rhinoceros 🐭 mouse 🐁 mouse2 🐀 rat 🐹 hamster 🐰 rabbit 🐇 rabbit2 🐿️ chipmunk 🦇 bat 🐻 bear 🐨 koala 🐼 panda_face 🐾 feet paw_prints ","date":"2019-10-01","objectID":"/myblog/emoji-support/:3:1","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"鸟类 图标 代码 图标 代码 🦃 turkey 🐔 chicken 🐓 rooster 🐣 hatching_chick 🐤 baby_chick 🐥 hatched_chick 🐦 bird 🐧 penguin 🕊 dove 🦅 eagle 🦆 duck 🦉 owl ","date":"2019-10-01","objectID":"/myblog/emoji-support/:3:2","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"两栖动物 icon code icon code 🐸 frog ","date":"2019-10-01","objectID":"/myblog/emoji-support/:3:3","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"爬虫类 图标 代码 图标 代码 🐊 crocodile 🐢 turtle 🦎 lizard 🐍 snake 🐲 dragon_face 🐉 dragon ","date":"2019-10-01","objectID":"/myblog/emoji-support/:3:4","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"海洋动物 图标 代码 图标 代码 🐳 whale 🐋 whale2 🐬 dolphin flipper 🐟 fish 🐠 tropical_fish 🐡 blowfish 🦈 shark 🐙 octopus 🐚 shell ","date":"2019-10-01","objectID":"/myblog/emoji-support/:3:5","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"虫类 图标 代码 图标 代码 🐌 snail 🦋 butterfly 🐛 bug 🐜 ant 🐝 bee honeybee 🪲 beetle 🕷️ spider 🕸️ spider_web 🦂 scorpion ","date":"2019-10-01","objectID":"/myblog/emoji-support/:3:6","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"花类植物 图标 代码 图标 代码 💐 bouquet 🌸 cherry_blossom 💮 white_flower 🏵️ rosette 🌹 rose 🥀 wilted_flower 🌺 hibiscus 🌻 sunflower 🌼 blossom 🌷 tulip ","date":"2019-10-01","objectID":"/myblog/emoji-support/:3:7","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"其它植物 图标 代码 图标 代码 🌱 seedling 🌲 evergreen_tree 🌳 deciduous_tree 🌴 palm_tree 🌵 cactus 🌾 ear_of_rice 🌿 herb ☘️ shamrock 🍀 four_leaf_clover 🍁 maple_leaf 🍂 fallen_leaf 🍃 leaves ","date":"2019-10-01","objectID":"/myblog/emoji-support/:3:8","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"食物与饮料 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:4:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"水果 图标 代码 图标 代码 🍇 grapes 🍈 melon 🍉 watermelon 🍊 mandarin orange tangerine 🍋 lemon 🍌 banana 🍍 pineapple 🍎 apple 🍏 green_apple 🍐 pear 🍑 peach 🍒 cherries 🍓 strawberry 🥝 kiwi_fruit 🍅 tomato ","date":"2019-10-01","objectID":"/myblog/emoji-support/:4:1","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"蔬菜 图标 代码 图标 代码 🥑 avocado 🍆 eggplant 🥔 potato 🥕 carrot 🌽 corn 🌶️ hot_pepper 🥒 cucumber 🍄 mushroom 🥜 peanuts 🌰 chestnut ","date":"2019-10-01","objectID":"/myblog/emoji-support/:4:2","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"快餐 图标 代码 图标 代码 🍞 bread 🥐 croissant 🥖 baguette_bread 🥞 pancakes 🧀 cheese 🍖 meat_on_bone 🍗 poultry_leg 🥓 bacon 🍔 hamburger 🍟 fries 🍕 pizza 🌭 hotdog 🌮 taco 🌯 burrito 🥙 stuffed_flatbread 🥚 egg 🍳 fried_egg 🥘 shallow_pan_of_food 🍲 stew 🥗 green_salad 🍿 popcorn ","date":"2019-10-01","objectID":"/myblog/emoji-support/:4:3","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"亚洲食物 图标 代码 图标 代码 🍱 bento 🍘 rice_cracker 🍙 rice_ball 🍚 rice 🍛 curry 🍜 ramen 🍝 spaghetti 🍠 sweet_potato 🍢 oden 🍣 sushi 🍤 fried_shrimp 🍥 fish_cake 🍡 dango ","date":"2019-10-01","objectID":"/myblog/emoji-support/:4:4","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"海鲜 图标 代码 图标 代码 🦀 crab 🦐 shrimp 🦑 squid ","date":"2019-10-01","objectID":"/myblog/emoji-support/:4:5","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"甜点 图标 代码 图标 代码 🍦 icecream 🍧 shaved_ice 🍨 ice_cream 🍩 doughnut 🍪 cookie 🎂 birthday 🍰 cake 🍫 chocolate_bar 🍬 candy 🍭 lollipop 🍮 custard 🍯 honey_pot ","date":"2019-10-01","objectID":"/myblog/emoji-support/:4:6","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"饮料 图标 代码 图标 代码 🍼 baby_bottle 🥛 milk_glass ☕ coffee 🍵 tea 🍶 sake 🍾 champagne 🍷 wine_glass 🍸 cocktail 🍹 tropical_drink 🍺 beer 🍻 beers 🥂 clinking_glasses 🥃 tumbler_glass ","date":"2019-10-01","objectID":"/myblog/emoji-support/:4:7","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"餐具 图标 代码 图标 代码 🍽️ plate_with_cutlery 🍴 fork_and_knife 🥄 spoon 🔪 hocho knife 🏺 amphora ","date":"2019-10-01","objectID":"/myblog/emoji-support/:4:8","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"旅游与地理 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"地图 图标 代码 图标 代码 🌍 earth_africa 🌎 earth_americas 🌏 earth_asia 🌐 globe_with_meridians 🗺️ world_map 🗾 japan ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:1","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"地理现象 图标 代码 图标 代码 🏔 mountain_snow ⛰️ mountain 🌋 volcano 🗻 mount_fuji 🏕️ camping ⛱ beach_umbrella 🏜️ desert 🏝️ desert_island 🏞️ national_park ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:2","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"建筑物 图标 代码 图标 代码 🏟️ stadium 🏛️ classical_building 🏗️ building_construction 🏘 houses 🏚 derelict_house 🏠 house 🏡 house_with_garden 🏢 office 🏣 post_office 🏤 european_post_office 🏥 hospital 🏦 bank 🏨 hotel 🏩 love_hotel 🏪 convenience_store 🏫 school 🏬 department_store 🏭 factory 🏯 japanese_castle 🏰 european_castle 💒 wedding 🗼 tokyo_tower 🗽 statue_of_liberty ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:3","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"宗教建筑 图标 代码 图标 代码 ⛪ church 🕌 mosque 🕍 synagogue ⛩️ shinto_shrine 🕋 kaaba ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:4","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"其它地点 图标 代码 图标 代码 ⛲ fountain ⛺ tent 🌁 foggy 🌃 night_with_stars 🏙️ cityscape 🌄 sunrise_over_mountains 🌅 sunrise 🌆 city_sunset 🌇 city_sunrise 🌉 bridge_at_night ♨️ hotsprings 🎠 carousel_horse 🎡 ferris_wheel 🎢 roller_coaster 💈 barber 🎪 circus_tent ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:5","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"陆路运输 图标 代码 图标 代码 🚂 steam_locomotive 🚃 railway_car 🚄 bullettrain_side 🚅 bullettrain_front 🚆 train2 🚇 metro 🚈 light_rail 🚉 station 🚊 tram 🚝 monorail 🚞 mountain_railway 🚋 train 🚌 bus 🚍 oncoming_bus 🚎 trolleybus 🚐 minibus 🚑 ambulance 🚒 fire_engine 🚓 police_car 🚔 oncoming_police_car 🚕 taxi 🚖 oncoming_taxi 🚗 car red_car 🚘 oncoming_automobile 🚙 blue_car 🚚 truck 🚛 articulated_lorry 🚜 tractor 🏎️ racing_car 🏍 motorcycle 🛵 motor_scooter 🚲 bike 🛴 kick_scooter 🚏 busstop 🛣️ motorway 🛤️ railway_track 🛢️ oil_drum ⛽ fuelpump 🚨 rotating_light 🚥 traffic_light 🚦 vertical_traffic_light 🛑 stop_sign 🚧 construction ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:6","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"水路运输 图标 代码 图标 代码 ⚓ anchor ⛵ boat sailboat 🛶 canoe 🚤 speedboat 🛳️ passenger_ship ⛴️ ferry 🛥️ motor_boat 🚢 ship ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:7","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"空中运输 图标 代码 图标 代码 ✈️ airplane 🛩️ small_airplane 🛫 flight_departure 🛬 flight_arrival 💺 seat 🚁 helicopter 🚟 suspension_railway 🚠 mountain_cableway 🚡 aerial_tramway 🛰️ artificial_satellite 🚀 rocket ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:8","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"旅馆 icon code icon code 🛎️ bellhop_bell ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:9","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"时间 图标 代码 图标 代码 ⌛ hourglass ⏳ hourglass_flowing_sand ⌚ watch ⏰ alarm_clock ⏱️ stopwatch ⏲️ timer_clock 🕰️ mantelpiece_clock 🕛 clock12 🕧 clock1230 🕐 clock1 🕜 clock130 🕑 clock2 🕝 clock230 🕒 clock3 🕞 clock330 🕓 clock4 🕟 clock430 🕔 clock5 🕠 clock530 🕕 clock6 🕡 clock630 🕖 clock7 🕢 clock730 🕗 clock8 🕣 clock830 🕘 clock9 🕤 clock930 🕙 clock10 🕥 clock1030 🕚 clock11 🕦 clock1130 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:10","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"天空与天气 图标 代码 图标 代码 🌑 new_moon 🌒 waxing_crescent_moon 🌓 first_quarter_moon 🌔 moon waxing_gibbous_moon 🌕 full_moon 🌖 waning_gibbous_moon 🌗 last_quarter_moon 🌘 waning_crescent_moon 🌙 crescent_moon 🌚 new_moon_with_face 🌛 first_quarter_moon_with_face 🌜 last_quarter_moon_with_face 🌡️ thermometer ☀️ sunny 🌝 full_moon_with_face 🌞 sun_with_face ⭐ star 🌟 star2 🌠 stars 🌌 milky_way ☁️ cloud ⛅ partly_sunny ⛈ cloud_with_lightning_and_rain 🌤 sun_behind_small_cloud 🌥 sun_behind_large_cloud 🌦 sun_behind_rain_cloud 🌧 cloud_with_rain 🌨 cloud_with_snow 🌩 cloud_with_lightning 🌪️ tornado 🌫️ fog 🌬 wind_face 🌀 cyclone 🌈 rainbow 🌂 closed_umbrella ☂️ open_umbrella ☂️ umbrella ⛱️ parasol_on_ground ⚡ zap ❄️ snowflake ☃️ snowman_with_snow ☃️ snowman ☄️ comet 🔥 fire 💧 droplet 🌊 ocean ","date":"2019-10-01","objectID":"/myblog/emoji-support/:5:11","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"活动 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:6:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"事件 图标 代码 图标 代码 🎃 jack_o_lantern 🎄 christmas_tree 🎆 fireworks 🎇 sparkler ✨ sparkles 🎈 balloon 🎉 tada 🎊 confetti_ball 🎋 tanabata_tree 🎍 bamboo 🎎 dolls 🎏 flags 🎐 wind_chime 🎑 rice_scene 🎀 ribbon 🎁 gift 🎗️ reminder_ribbon 🎟 tickets 🎫 ticket ","date":"2019-10-01","objectID":"/myblog/emoji-support/:6:1","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"奖杯与奖牌 图标 代码 图标 代码 🎖️ medal_military 🏆 trophy 🏅 medal_sports 🥇 1st_place_medal 🥈 2nd_place_medal 🥉 3rd_place_medal ","date":"2019-10-01","objectID":"/myblog/emoji-support/:6:2","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"体育运动 图标 代码 图标 代码 ⚽ soccer ⚾ baseball 🏀 basketball 🏐 volleyball 🏈 football 🏉 rugby_football 🎾 tennis 🎳 bowling 🦗 cricket 🏑 field_hockey 🏒 ice_hockey 🏓 ping_pong 🏸 badminton 🥊 boxing_glove 🥋 martial_arts_uniform 🥅 goal_net ⛳ golf ⛸️ ice_skate 🎣 fishing_pole_and_fish 🎽 running_shirt_with_sash 🎿 ski ","date":"2019-10-01","objectID":"/myblog/emoji-support/:6:3","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"游戏 图标 代码 图标 代码 🎯 dart 🎱 8ball 🔮 crystal_ball 🎮 video_game 🕹️ joystick 🎰 slot_machine 🎲 game_die ♠️ spades ♥️ hearts ♦️ diamonds ♣️ clubs 🃏 black_joker 🀄 mahjong 🎴 flower_playing_cards ","date":"2019-10-01","objectID":"/myblog/emoji-support/:6:4","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"艺术与工艺 图标 代码 图标 代码 🎭 performing_arts 🖼 framed_picture 🎨 art ","date":"2019-10-01","objectID":"/myblog/emoji-support/:6:5","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"物品 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"服装 图标 代码 图标 代码 👓 eyeglasses 🕶️ dark_sunglasses 👔 necktie 👕 shirt tshirt 👖 jeans 👗 dress 👘 kimono 👙 bikini 👚 womans_clothes 👛 purse 👜 handbag 👝 pouch 🛍️ shopping 🎒 school_satchel 👞 mans_shoe shoe 👟 athletic_shoe 👠 high_heel 👡 sandal 👢 boot 👑 crown 👒 womans_hat 🎩 tophat 🎓 mortar_board ⛑️ rescue_worker_helmet 📿 prayer_beads 💄 lipstick 💍 ring 💎 gem ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:1","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"声音 图标 代码 图标 代码 🔇 mute 🔈 speaker 🔉 sound 🔊 loud_sound 📢 loudspeaker 📣 mega 📯 postal_horn 🔔 bell 🔕 no_bell ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:2","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"音乐 图标 代码 图标 代码 🎼 musical_score 🎵 musical_note 🎶 notes 🎙️ studio_microphone 🎚️ level_slider 🎛️ control_knobs 🎤 microphone 🎧 headphones 📻 radio ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:3","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"乐器 图标 代码 图标 代码 🎷 saxophone 🎸 guitar 🎹 musical_keyboard 🎺 trumpet 🎻 violin 🥁 drum ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:4","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"电话 图标 代码 图标 代码 📱 iphone 📲 calling ☎️ phone telephone 📞 telephone_receiver 📟 pager 📠 fax ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:5","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"电脑 图标 代码 图标 代码 🔋 battery 🔌 electric_plug 💻 computer 🖥️ desktop_computer 🖨️ printer ⌨️ keyboard 🖱 computer_mouse 🖲️ trackball 💽 minidisc 💾 floppy_disk 💿 cd 📀 dvd ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:6","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"灯光与影像 图标 代码 图标 代码 🎥 movie_camera 🎞️ film_strip 📽️ film_projector 🎬 clapper 📺 tv 📷 camera 📸 camera_flash 📹 video_camera 📼 vhs 🔍 mag 🔎 mag_right 🕯️ candle 💡 bulb 🔦 flashlight 🏮 izakaya_lantern lantern ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:7","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"书与纸张 图标 代码 图标 代码 📔 notebook_with_decorative_cover 📕 closed_book 📖 book open_book 📗 green_book 📘 blue_book 📙 orange_book 📚 books 📓 notebook 📒 ledger 📃 page_with_curl 📜 scroll 📄 page_facing_up 📰 newspaper 🗞️ newspaper_roll 📑 bookmark_tabs 🔖 bookmark 🏷️ label ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:8","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"钱 图标 代码 图标 代码 💰 moneybag 💴 yen 💵 dollar 💶 euro 💷 pound 💸 money_with_wings 💳 credit_card 💹 chart ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:9","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"邮件 图标 代码 图标 代码 ✉️ email envelope 📧 📧 📨 incoming_envelope 📩 envelope_with_arrow 📤 outbox_tray 📥 inbox_tray 📦 package 📫 mailbox 📪 mailbox_closed 📬 mailbox_with_mail 📭 mailbox_with_no_mail 📮 postbox 🗳 ballot_box ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:10","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"书写 图标 代码 图标 代码 ✏️ pencil2 ✒️ black_nib 🖋 fountain_pen 🖊 pen 🖌 paintbrush 🖍 crayon 📝 memo pencil ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:11","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"办公 图标 代码 图标 代码 💼 briefcase 📁 file_folder 📂 open_file_folder 🗂️ card_index_dividers 📅 date 📆 calendar 🗒 spiral_notepad 🗓 spiral_calendar 📇 card_index 📈 chart_with_upwards_trend 📉 chart_with_downwards_trend 📊 bar_chart 📋 clipboard 📌 pushpin 📍 round_pushpin 📎 paperclip 🖇 paperclips 📏 straight_ruler 📐 triangular_ruler ✂️ scissors 🗃️ card_file_box 🗄️ file_cabinet 🗑️ wastebasket ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:12","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"锁 图标 代码 图标 代码 🔒 lock 🔓 unlock 🔏 lock_with_ink_pen 🔐 closed_lock_with_key 🔑 key 🗝️ old_key ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:13","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"工具 图标 代码 图标 代码 🔨 hammer ⛏️ pick ⚒️ hammer_and_pick 🛠️ hammer_and_wrench 🗡 dagger ⚔️ crossed_swords 🔫 gun 🏹 bow_and_arrow 🛡️ shield 🔧 wrench 🔩 nut_and_bolt ⚙️ gear 🗜 clamp ⚖ balance_scale 🔗 link ⛓️ chains ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:14","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"科学 图标 代码 图标 代码 ⚗️ alembic 🔬 microscope 🔭 telescope 🛰️ satellite ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:15","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"医疗 图标 代码 图标 代码 💉 syringe 💊 pill ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:16","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"生活用品 图标 代码 图标 代码 🚪 door 🛏️ bed 🛋️ couch_and_lamp 🚽 toilet 🚿 shower 🛁 bathtub 🛒 shopping_cart ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:17","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"其它物品 图标 代码 图标 代码 🚬 smoking ⚰️ coffin ⚱️ funeral_urn 🗿 moyai ","date":"2019-10-01","objectID":"/myblog/emoji-support/:7:18","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"符号 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"交通标识 图标 代码 图标 代码 🏧 atm 🚮 put_litter_in_its_place 🚰 potable_water ♿ wheelchair 🚹 mens 🚺 womens 🚻 restroom 🚼 baby_symbol 🚾 wc 🛂 passport_control 🛃 customs 🛄 baggage_claim 🛅 left_luggage ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:1","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"警告 图标 代码 图标 代码 ⚠️ warning 🚸 children_crossing ⛔ no_entry 🚫 no_entry_sign 🚳 no_bicycles 🚭 no_smoking 🚯 do_not_litter 🚱 🚱 🚷 no_pedestrians 📵 no_mobile_phones 🔞 underage ☢ radioactive ☣ biohazard ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:2","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"箭头 图标 代码 图标 代码 ⬆️ arrow_up ↗️ arrow_upper_right ➡️ arrow_right ↘️ arrow_lower_right ⬇️ arrow_down ↙️ arrow_lower_left ⬅️ arrow_left ↖️ arrow_upper_left ↕️ arrow_up_down ↔️ left_right_arrow ↩️ leftwards_arrow_with_hook ↪️ arrow_right_hook ⤴️ arrow_heading_up ⤵️ arrow_heading_down 🔃 arrows_clockwise 🔄 arrows_counterclockwise 🔙 back 🔚 end 🔛 on 🔜 soon 🔝 top ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:3","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"宗教 图标 代码 图标 代码 🛐 place_of_worship ⚛️ atom_symbol 🕉 om ✡️ star_of_david ☸️ wheel_of_dharma ☯️ yin_yang ✝️ latin_cross ☦️ orthodox_cross ☪️ star_and_crescent ☮️ peace_symbol 🕎 menorah 🔯 six_pointed_star ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:4","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"生肖 图标 代码 图标 代码 ♈ aries ♉ taurus ♊ gemini ♋ cancer ♌ leo ♍ virgo ♎ libra ♏ scorpius ♐ sagittarius ♑ capricorn ♒ aquarius ♓ pisces ⛎ ophiuchus ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:5","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"影像符号 图标 代码 图标 代码 🔀 twisted_rightwards_arrows 🔁 repeat 🔂 repeat_one ▶️ arrow_forward ⏩ fast_forward ⏭ next_track_button ⏯ play_or_pause_button ◀️ arrow_backward ⏪ rewind ⏮️ previous_track_button 🔼 arrow_up_small ⏫ arrow_double_up 🔽 arrow_down_small ⏬ arrow_double_down ⏸ pause_button ⏹ stop_button ⏺ record_button 🎦 cinema 🔅 low_brightness 🔆 high_brightness 📶 signal_strength 📳 vibration_mode 📴 mobile_phone_off ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:6","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"数学 图标 代码 图标 代码 ✖️ heavy_multiplication_x ➕ heavy_plus_sign ➖ heavy_minus_sign ➗ heavy_division_sign ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:7","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"标点符号 图标 代码 图标 代码 ‼️ bangbang ⁉️ interrobang ❓ question ❔ grey_question ❕ grey_exclamation ❗ exclamation heavy_exclamation_mark 〰️ wavy_dash ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:8","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"货币 图标 代码 图标 代码 💱 currency_exchange 💲 heavy_dollar_sign ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:9","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"按键符号 图标 代码 图标 代码 #️⃣ hash *️⃣ asterisk 0️⃣ zero 1️⃣ one 2️⃣ two 3️⃣ three 4️⃣ four 5️⃣ five 6️⃣ six 7️⃣ seven 8️⃣ eight 9️⃣ nine 🔟 keycap_ten ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:10","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"字母符号 图标 代码 图标 代码 🔠 capital_abcd 🔡 abcd 🔢 1234 🔣 symbols 🔤 abc 🅰️ a 🆎 ab 🅱️ b 🆑 cl 🆒 cool 🆓 free ℹ️ information_source 🆔 id ⓜ️ m 🆕 new 🆖 ng 🅾️ o2 🆗 ok 🅿️ parking 🆘 sos 🆙 up 🆚 vs 🈁 koko 🈂️ sa 🈷️ u6708 🈶 u6709 🈯 u6307 🉐 ideograph_advantage 🈹 u5272 🈚 u7121 🈲 u7981 🉑 accept 🈸 u7533 🈴 u5408 🈳 u7a7a ㊗️ congratulations ㊙️ secret 🈺 u55b6 🈵 u6e80 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:11","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"几何符号 图标 代码 图标 代码 🔴 red_circle 🔵 large_blue_circle ⚫ black_circle ⚪ white_circle ⬛ black_large_square ⬜ white_large_square ◼️ black_medium_square ◻️ white_medium_square ◾ black_medium_small_square ◽ white_medium_small_square ▪️ black_small_square ▫️ white_small_square 🔶 large_orange_diamond 🔷 large_blue_diamond 🔸 small_orange_diamond 🔹 small_blue_diamond 🔺 small_red_triangle 🔻 small_red_triangle_down 💠 diamond_shape_with_a_dot_inside 🔘 radio_button 🔳 white_square_button 🔲 black_square_button ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:12","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"其它符合 图标 代码 图标 代码 ♻️ recycle ⚜️ fleur_de_lis 🔱 trident 📛 name_badge 🔰 beginner ⭕ o ✅ white_check_mark ☑️ ballot_box_with_check ✔️ heavy_check_mark ❌ x ❎ negative_squared_cross_mark ➰ curly_loop ➿ loop 〽️ part_alternation_mark ✳️ eight_spoked_asterisk ✴️ eight_pointed_black_star ❇️ sparkle ©️ copyright ®️ registered ™️ tm ","date":"2019-10-01","objectID":"/myblog/emoji-support/:8:13","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"旗帜 ","date":"2019-10-01","objectID":"/myblog/emoji-support/:9:0","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"常用旗帜 图标 代码 图标 代码 🏁 checkered_flag 🚩 triangular_flag_on_post 🎌 crossed_flags 🏴 black_flag 🏳 white_flag 🏳️‍🌈 rainbow_flag ","date":"2019-10-01","objectID":"/myblog/emoji-support/:9:1","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":["Markdown"],"content":"国家和地区旗帜 图标 代码 图标 代码 🇦🇩 andorra 🇦🇪 united_arab_emirates 🇦🇫 afghanistan 🇦🇬 antigua_barbuda 🇦🇮 anguilla 🇦🇱 albania 🇦🇲 armenia 🇦🇴 angola 🇦🇶 antarctica 🇦🇷 argentina 🇦🇸 american_samoa 🇦🇹 austria 🇦🇺 australia 🇦🇼 aruba 🇦🇽 aland_islands 🇦🇿 azerbaijan 🇧🇦 bosnia_herzegovina 🇧🇧 barbados 🇧🇩 bangladesh 🇧🇪 belgium 🇧🇫 burkina_faso 🇧🇬 bulgaria 🇧🇭 bahrain 🇧🇮 burundi 🇧🇯 benin 🇧🇱 st_barthelemy 🇧🇲 bermuda 🇧🇳 brunei 🇧🇴 bolivia 🇧🇶 caribbean_netherlands 🇧🇷 brazil 🇧🇸 bahamas 🇧🇹 bhutan 🇧🇼 botswana 🇧🇾 belarus 🇧🇿 belize 🇨🇦 canada 🇨🇨 cocos_islands 🇨🇩 congo_kinshasa 🇨🇫 central_african_republic 🇨🇬 congo_brazzaville 🇨🇭 switzerland 🇨🇮 cote_divoire 🇨🇰 cook_islands 🇨🇱 chile 🇨🇲 cameroon 🇨🇳 cn 🇨🇴 colombia 🇨🇷 costa_rica 🇨🇺 cuba 🇨🇻 cape_verde 🇨🇼 curacao 🇨🇽 christmas_island 🇨🇾 cyprus 🇨🇿 czech_republic 🇩🇪 de 🇩🇯 djibouti 🇩🇰 denmark 🇩🇲 dominica 🇩🇴 dominican_republic 🇩🇿 algeria 🇪🇨 ecuador 🇪🇪 estonia 🇪🇬 egypt 🇪🇭 western_sahara 🇪🇷 eritrea 🇪🇸 es 🇪🇹 ethiopia 🇪🇺 eu european_union 🇫🇮 finland 🇫🇯 fiji 🇫🇰 falkland_islands 🇫🇲 micronesia 🇫🇴 faroe_islands 🇫🇷 fr 🇬🇦 gabon 🇬🇧 gb uk 🇬🇩 grenada 🇬🇪 georgia 🇬🇫 french_guiana 🇬🇬 guernsey 🇬🇭 ghana 🇬🇮 gibraltar 🇬🇱 greenland 🇬🇲 gambia 🇬🇳 guinea 🇬🇵 guadeloupe 🇬🇶 equatorial_guinea 🇬🇷 greece 🇬🇸 south_georgia_south_sandwich_islands 🇬🇹 guatemala 🇬🇺 guam 🇬🇼 guinea_bissau 🇬🇾 guyana 🇭🇰 hong_kong 🇭🇳 honduras 🇭🇷 croatia 🇭🇹 haiti 🇭🇺 hungary 🇮🇨 canary_islands 🇮🇩 indonesia 🇮🇪 ireland 🇮🇱 israel 🇮🇲 isle_of_man 🇮🇳 india 🇮🇴 british_indian_ocean_territory 🇮🇶 iraq 🇮🇷 iran 🇮🇸 iceland 🇮🇹 it 🇯🇪 jersey 🇯🇲 jamaica 🇯🇴 jordan 🇯🇵 jp 🇰🇪 kenya 🇰🇬 kyrgyzstan 🇰🇭 cambodia 🇰🇮 kiribati 🇰🇲 comoros 🇰🇳 st_kitts_nevis 🇰🇵 north_korea 🇰🇷 kr 🇰🇼 kuwait 🇰🇾 cayman_islands 🇰🇿 kazakhstan 🇱🇦 laos 🇱🇧 lebanon 🇱🇨 st_lucia 🇱🇮 liechtenstein 🇱🇰 sri_lanka 🇱🇷 liberia 🇱🇸 lesotho 🇱🇹 lithuania 🇱🇺 luxembourg 🇱🇻 latvia 🇱🇾 libya 🇲🇦 morocco 🇲🇨 monaco 🇲🇩 moldova 🇲🇪 montenegro 🇲🇬 madagascar 🇲🇭 marshall_islands 🇲🇰 macedonia 🇲🇱 mali 🇲🇲 myanmar 🇲🇳 mongolia 🇲🇴 macau 🇲🇵 northern_mariana_islands 🇲🇶 martinique 🇲🇷 mauritania 🇲🇸 montserrat 🇲🇹 malta 🇲🇺 mauritius 🇲🇻 maldives 🇲🇼 malawi 🇲🇽 mexico 🇲🇾 malaysia 🇲🇿 mozambique 🇳🇦 namibia 🇳🇨 new_caledonia 🇳🇪 niger 🇳🇫 norfolk_island 🇳🇬 nigeria 🇳🇮 nicaragua 🇳🇱 netherlands 🇳🇴 norway 🇳🇵 nepal 🇳🇷 nauru 🇳🇺 niue 🇳🇿 new_zealand 🇴🇲 oman 🇵🇦 panama 🇵🇪 peru 🇵🇫 french_polynesia 🇵🇬 papua_new_guinea 🇵🇭 philippines 🇵🇰 pakistan 🇵🇱 poland 🇵🇲 st_pierre_miquelon 🇵🇳 pitcairn_islands 🇵🇷 puerto_rico 🇵🇸 palestinian_territories 🇵🇹 portugal 🇵🇼 palau 🇵🇾 paraguay 🇶🇦 qatar 🇷🇪 reunion 🇷🇴 romania 🇷🇸 serbia 🇷🇺 ru 🇷🇼 rwanda 🇸🇦 saudi_arabia 🇸🇧 solomon_islands 🇸🇨 seychelles 🇸🇩 sudan 🇸🇪 sweden 🇸🇬 singapore 🇸🇭 st_helena 🇸🇮 slovenia 🇸🇰 slovakia 🇸🇱 sierra_leone 🇸🇲 san_marino 🇸🇳 senegal 🇸🇴 somalia 🇸🇷 suriname 🇸🇸 south_sudan 🇸🇹 sao_tome_principe 🇸🇻 el_salvador 🇸🇽 sint_maarten 🇸🇾 syria 🇸🇿 swaziland 🇹🇨 turks_caicos_islands 🇹🇩 chad 🇹🇫 french_southern_territories 🇹🇬 togo 🇹🇭 thailand 🇹🇯 tajikistan 🇹🇰 tokelau 🇹🇱 timor_leste 🇹🇲 turkmenistan 🇹🇳 tunisia 🇹🇴 tonga 🇹🇷 tr 🇹🇹 trinidad_tobago 🇹🇻 tuvalu 🇹🇼 taiwan 🇹🇿 tanzania 🇺🇦 ukraine 🇺🇬 uganda 🇺🇸 us 🇺🇾 uruguay 🇺🇿 uzbekistan 🇻🇦 vatican_city 🇻🇨 st_vincent_grenadines 🇻🇪 venezuela 🇻🇬 british_virgin_islands 🇻🇮 us_virgin_islands 🇻🇳 vietnam 🇻🇺 vanuatu 🇼🇫 wallis_futuna 🇼🇸 samoa 🇽🇰 kosovo 🇾🇪 yemen 🇾🇹 mayotte 🇿🇦 south_africa 🇿🇲 zambia 🇿🇼 zimbabwe ","date":"2019-10-01","objectID":"/myblog/emoji-support/:9:2","tags":["emoji"],"title":"Emoji 支持","uri":"/myblog/emoji-support/"},{"categories":null,"content":"关于 LoveIt","date":"2019-08-02","objectID":"/myblog/about/","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"  LoveIt 是一个由  Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/myblog/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"特性 ","date":"2019-08-02","objectID":"/myblog/about/:1:0","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持 Yandex Metrica  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 ","date":"2019-08-02","objectID":"/myblog/about/:1:1","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"外观和布局  桌面端/移动端 响应式布局  浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 73 种社交链接  支持多达 24 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook comments 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 utterances 评论系统  支持 giscus 评论系统 ","date":"2019-08-02","objectID":"/myblog/about/:1:2","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightGallery 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $\\KaTeX$ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 cookieconsent 的 Cookie 许可横幅  支持人物标签的 shortcode … ","date":"2019-08-02","objectID":"/myblog/about/:1:3","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 ","date":"2019-08-02","objectID":"/myblog/about/:2:0","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"特别感谢 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/myblog/about/:3:0","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"}]