[{"categories":["Docker"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"前言 在我这可以，在你那怎么就跑不起来了？ 在以前，项目开发完成后，测试/运维需要从头到尾搭建环境、调试。这样的话经常出现在开发的口中，不过，随着技术的不断发展，在容器技术诞生后，这个问题就可以轻松的解决了。容器技术就像一个打包工具，使我们可以以与管理应用程序相同的方式管理基础架构。部署操作都命令化，集中成一个脚本就可以完成原来复杂的部署过程。打包的不仅是你的程序，也包括运行的环境，因此消除了我们重复的、单调的配置/调试任务。项目在打包后可以在所有的环境下，以相同的方式运行。让开发测试等成员不再关注构建、调试等事情。可以将更多的时间放在业务本身。 docker 简介 不同于虚拟机，容器技术只隔离应用程序的运行环境但容器之间可以共用同一个操作系统，这使它在继承了虚拟机优点的同时还摒弃了其缺点。而 docker，则是容器技术的其中一种实现。 docker 是一个用 Go 语言实现的开源项目，可以让我们方便的创建和使用容器。 docker 使用客户端-服务器架构。客户端通过一些命令行与守护进程交互，守护进程管理 Docker 对象，如镜像、容器、网络和 volume。 docker 三要素 image：镜像，一个只读模版，其中包含创建 Dokcer 容器的说明。 container：容器，镜像的可运行实例。可以使用 docker cli 创建/启动/停止/删除/移动容器。同一个镜像，可以生成多个同时运行的容器。容器之间默认相互隔离。 repository：镜像仓库，存放了各种各样的 image，相当于代码仓库中的 github。 docker 的基本使用 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:0","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"根据镜像启动一个容器 # 前置 # 使用apt（或其他）下载docker apt install docker # 例 # 使用 run命令 启动一个容器 docker run \u003cimage name\u003e docker run ubuntu 当系统内没有 ubuntu 镜像时会自动去 docker hub 上拉取后再启动容器。默认attached模式，会占用当前窗口并展示实时日志。可以通过Ctrl + c停止 docker 服务。更适用于容器和程序的调试阶段。 如果想在后台运行可以（使用detached模式）docker run -d \u003c image name \u003e docker run -d ubuntu # 查看在后台运行的容器的日志 # docker logs \u003cname or id\u003e ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:1","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"查看已启动的容器 docker ps # 会打印当前运行的docker容器信息 # id 容器id # image 镜像名称 # status 状态 up/exited ... # ports 协议和端口 # names 容器名称 ... docker ps 只能查看运行的容器，如果要查看所有容器（包括已停止的）可以加个 -a参数:docker ps -a 只查看容器 id 可以加个-q参数：docker ps -q(可以搭配 docker rm 使用 进行批量删除实例： docker rm $(docker container ps -aq)) ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:2","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"停止/启动/重启/删除一个已启动的容器 docker stop \u003cname or id\u003e docker start \u003cname or id\u003e docker restart \u003cname or id\u003e docker rm \u003cname or id\u003e # 删除容器前需要先停止容器。或加上强制删除参数 -f ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:3","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"开启容器的交互 有时候容器不是一个简单的服务，而是需要交互的操作系统，可以在使用detached模式启动容器后使用 exec 进入容器进行交互 docker exec -it \u003cname or id\u003e sh # exec 执行 # -it 交互模式 # sh 使用shell脚本进行交互 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:4","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"其他 #image docker pull \u003cimage name\u003e # 在docker hub中拉取镜像 docker image ls #查看已有的镜像信息 docker image inspect \u003cimage id\u003e #查看镜像详细信息，例如镜像id，暴露出的端口，volumn位置等。 # 导出一个已有的镜像，执行后，当前文件夹下会生成一个镜像文件 # save：导出； # \u003cname:tag\u003e:镜像名称：版本； # -o: 输出 # fileName：导出后的文件名称 docker image save \u003cname:tag\u003e -o \u003cfileName\u003e # 导入一个已有的镜像 # \u003c./filename\u003e 要导入的镜像文件路径 docker image load -i \u003c./filename\u003e 使用 Dockerfile 构建自己的镜像 之前使用的是已创建好的镜像， 我们可以自定义一个 Dockerfile 文件来构建自己的镜像。一般我们会在应用程序根目录与 package.json 同级目录下创建 Dockerfile 文件。 Dockerfile 是一个文本文件，它包含了用户可以在命令行上调用的 docker 构建景象相关的所有命令，它遵循特定的格式和指令集，指令名称和参数以空格分隔，指令名称不区分大小写，但 Docker 约定它们是大写的，以便更容易的区分指令和参数。其他具体指令可以参考 Dockerfile 语法,每个语法指令都会在图像中创建一个图层，当您更改 Dockerfile 并重建映像时，只有那些已更改的图层才会被重建。这也是镜像相对小巧、快速的部分原因。 说几个常用的语法指令： ARG: 用来定义参数的命令,可以在打包镜像时使用docker build --build-arg \u003cvarname\u003e=\u003cvalue\u003e 命令将变量值传递到 Dockerfile 内部，如果 ARG 指令有默认值并且在构建时没有传递任何值，则构建器使用默认值。 # ARG \u003cname\u003e[=\u003cdefault value\u003e] ARG data ARG name=zhangsan ARG age=18 FORM: 在 Dockerfile 里，除去 ARG 指令外，一个有效的 Dockerfile 必须由 FROM 指令开头，用来指定你要构建镜像的基础镜像。FROM 指令前面只能有一个或多个 ARG 指令，用来声明 FROM 行使用的参数。 WORKDIR：用来定义镜像运行后的工作目录 COPY: 用来将主机的文件复制到镜像中，. . 表示将当前目录复制到容器中。 CMD：打包好的镜像在启动后默认执行的命令。 ESPOSE：用来暴露镜像的端口号，告知使用容器的人，当前镜像需要监听的的端口和协议。暴露出来后，可以在镜像打包后，通过 docker inspect \u003cimage id\u003e 来查看暴露出的端口。 # cd /app # vi Dockerfile FROM node:18-alpine WORKDIR /app COPY . . CMD [\"node\", \"src/index.js\"] EXPOSE 3000 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:5","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"使用docker build根据Dockerfile构建镜像 # 根据Dockerfile构建镜像 # build 构建命令 # -t \u003cimage name\u003e通过-t给要打包的镜像取一个名字 # path Dockerfile文件所在路径 # docker build -t \u003cimage name\u003e \u003cpath:相对路径，根据这个路径寻找Dockerfile文件\u003e .表示它应该在当前目录中查找Dockerfile。 # 例 docker build -t tzzimage . # 路径是必填项 . 指的是当前路径 打包完成后，docker image ls查看已有镜像发现 tzzimage 镜像已经存在了。 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:6","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"运行构建好的镜像 # -d 从后台启动容器 # -p port:port: 指定端口映射，第一个port表示主机要发布的端口，第二个是容器暴露的端口。没有端口映射将无法访问在容器中启动的应用程序。 docker run -dp 3000:3000 tzzimage 执行后，就可以访问 http://localhost:3000 了。 还可以通过docker ps查看容器状态 ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:7","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["Docker"],"content":"状态管理 启动后的容器是无状态的，虽然可以容器中创建、更新、删除文件，但随着容器的关闭，相关的数据并不会得到保留，但是在日常使用中，经常会遇到一些需要保留数据的容器，或者在多个容器之间进行数据共享。这就涉及到了容器的数据管理。需要对容器中的数据进行持久化。 Volume volume 提供了将容器特定文件到主机的能力，如果在容器启动时挂载容器中的目录，则该目录的更改也会在主机上看到。我们跨容器重新启动并挂载同一目录，我们会看到相同的文件。 使用docker volume create命令创建卷。 docker volume create volume1 执行 docker run 命令时添加–mount 选项指定 volumn 挂载， docker run -dp 3000:3000 --mount type=volume,src=volume1,target=/app tzzimage # or docker run -dp 3000:3000 -v volume1:/app tzzimage 表示我们使用了 volume1 volume，并将其挂载到了容器内的/app 目录下，如果该 volume 未被创建时，docker 会自动帮我们创建 在容器启动后，我们在/app 目录下创建一个文件 aaa.txt. 把容器删除后重新指定 volume 创建，会发现 aaa.txt 依旧存在。 通过 docker volume inspect 命令来查看 volume 详情, Mountpoint 属性，是主机磁盘存储数据的实际位置。docker 会把数据存储在这个地方，当我们使用这个 volume 启动容器的时候会把这个目录挂载到容器中 docker volume inspect todo-db [ { \"CreatedAt\": \"2023-02-22T09:23:11Z\", \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/volume1/_data\", \"Name\": \"volume1\", \"Options\": {}, \"Scope\": \"local\" } ] 通过这种方式，我们可以持久性的存储应用程序的数据，但在某些情况下，还有另外一种类型的状态管理。 bind bind 是另一种挂载方式，他允许你将主机文件系统的目录共享到容器中。在处理应用程序时，您可以使用 bind 方式，将程序源代码挂载到容器中。一旦在容器外部保存文件，容器内就会立即看到您对代码所做的更改。这意味着我们可以在容器中运行进程，监视文件系统更改并响应它们。我们可以搭配着 nodemon，对已启动的程序进行热更新。常常在本地开发调试的时候使用。 docker run -dp 3000:3000 --mount type=bind,src=/app,target=/app tzzimage ","date":"2023-02-23","objectID":"/myblog/docker%E5%88%9D%E8%AF%86/:0:8","tags":["docker"],"title":"Docker初识","uri":"/myblog/docker%E5%88%9D%E8%AF%86/"},{"categories":["前端"],"content":"这篇文章展示了web Component的基本使用","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"Web Component 本身不是一个规范，而是一组技术的应用，Web Component 现阶段主要分为三部分：Custom element、Shadow DOM、Template。通过它们的搭配使用，可以让我们在不借助第三方框架（react，vue）的情况下，构建独立的，可重用的自定义组件。 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:0:0","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"Custom element(自定义元素) Custom element 是一组 javasrcipt API，它允许我们自定义一些定制元素及行为。 \u003cbody\u003e \u003c!-- 组建使用 --\u003e \u003cbox-div color=\"orange\" text=\"hello\"\u003e\u003c/box-div\u003e \u003c/body\u003e \u003c!-- 组建定义 --\u003e \u003cscript\u003e class boxDiv extends HTMLElement { constructor() { super(); this.style.color = this.getAttribute('color'); this.append(this.getAttribute('text')); } } window.customElements.define('box-div', boxDiv); \u003c/script\u003e js 提供了customElements.define api，用来注册自定义元素，customElements.define()接收三个参数： 符合命名标准的参数名称（不能是单个单词，且必须要有短横线） 用于定义行为的类 可选参数：一个包含 extends属性的配置对象，指定所创建元素继承于哪个内置的 HTML 元素。 Custom element 有两种定义元素的方式，没有传递第三个参数表示独立创建，不继承内置元素。在使用时可以直接写成 HTML 标签的形式来使用，例如\u003cword-count\u003e 或者通过 js 创建document.createElement(“word-count”) 。 若在定义元素时指定了所扩展的元素，表示继承创建。在使用时则需要先写出基本的元素标签，并通过is 指定所扩展的元素。 customElements.define('word-count', WordCount, { extends: 'p' }); // 使用方式 \u003cp is=\"word-count\"\u003e\u003c/p\u003e; // 或 document.createElement('p', { is: 'word-count' }); 它还可以指定一些回调函数，它们将在元素不同的生命时期被调用 connectedCallback：当 custom element 首次被插入文档 DOM 时，被调用。 disconnectedCallback：当 custom element 从文档 DOM 中删除时，被调用。 adoptedCallback：当 custom element 被移动到新的文档时，被调用。 attributeChangedCallback: 当 custom element 增加、删除、修改自身属性时，被调用。 class boxDiv extends HTMLElement { static get observedAttributes() { return ['class', 'style']; } constructor() { super(); this.style.color = this.getAttribute('color'); this.append(this.getAttribute('text')); } public connectedCallback() { console.log('元素插入DOM中.'); } public disconnectedCallback(){ console.log('元素被删除.'); } public adoptedCallback(){ console.log('元素被移动.'); } public attributeChangedCallback(name, oldValue, newValue){ console.log('元素属性变更.' name，oldValue， newValue); } } 注：想在某个元素属性变化后，触发attributeChangedCallback()回调函数，需要先必须监听这个属性。这可以通过定义observedAttributes() get 函数来实现，observedAttributes() 函数体内包含一个 return 语句，返回一个数组，包含了需要监听的属性名称。监听后。每当元素的属性变化时，attributeChangedCallback()回调函数会执行。我们可以查看属性的名称、旧值与新值。 通过这些生命周期函数，我们可以动态的变更我们的 web 组件。 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:1:0","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"Shadow DOM（影子 DOM） Shadow DOM 也有一组 javascript API，他不是一个新事物，它允许我们在常规 DOM 元素上附加一个独立隐藏的特殊类型 DOM 元素。这部分的代码与外部代码相互隔离。内部的任何代码都无法影响外部。 通过 Shadow DOM 和 Custom element 搭配的方式，可以保证自定义元素的独立。使其不会影响到它外部的元素。 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:2:0","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"基本用法 可以使用 Element.attachShadow() 方法来将一个 shadow root 附加到任何一个元素上。它接受一个配置对象作为参数，该对象有一个 mode 属性，值可以是 open 或者 closed： let shadow = elementRef.attachShadow({ mode: 'open' }); let shadow = elementRef.attachShadow({ mode: 'closed' }); open 表示可以通过页面内的 javascript 方法来获取 Shadow DOM。 let myShadowDom = myCustomElem.shadowRoot; 如果你将一个 Shadow root 附加到一个 Custom element 上，并且将 mode 设置为 closed，那么就不可以从外部获取 Shadow DOM 了。myCustomElem.shadowRoot 将会返回 null。 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:2:1","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"实现一个简单的 tooltip \u003cbody\u003e \u003cpopup-info text=\"一个点击可直接暴富的朴素按钮\"\u003ebutton\u003c/popup-info\u003e \u003c/body\u003e \u003cscript\u003e class PopUpInfo extends HTMLElement { constructor() { super(); const shadow = this.attachShadow({ mode: 'open' }); const style = document.createElement('style'); style.textContent = ` .wrapper { position: relative; top: 100px; left: 10px; } .info { font-size: 14px; width: 200px; display: inline-block; border: 1px solid black; padding: 10px; background: white; border-radius: 10px; opacity: 0; transition: 0.6s all; position: absolute; bottom: 20px; left: 10px; z-index: 3; } .title:hover + .info, .title:focus + .info { opacity: 1; } `; shadow.appendChild(style); const wrapper = document.createElement('span'); wrapper.setAttribute('class', 'wrapper'); shadow.appendChild(wrapper); // title信息 const titleDom = document.createElement('span'); titleDom.setAttribute('class', 'title'); const title = this.innerHTML; titleDom.append(title); wrapper.appendChild(titleDom); // tooltip信息 const infoDom = document.createElement('span'); infoDom.setAttribute('class', 'info'); const text = this.getAttribute('text'); infoDom.textContent = text; wrapper.appendChild(infoDom); } } customElements.define('popup-info', PopUpInfo); \u003c/script\u003e 定义一个自定义 DOM，然后创建一个 shadowDOM，给 shadowDOM 新增子标签style titleSpan infoSpan 。 最后将 shadowDOM 附加到自定义 DOM 上。一个简单的 tooltip 就实现了。 目前看起来还有一些问题，比如我写 style 的方式是用模版字符串写的。比如我用的 jsAPI 生成的 dom 元素。可读性较差。再比如目前的提示信息只接收字符串，不支持 DOM 类型。这些问题可以使用 template 和 slot 来解决。 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:2:2","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"HTML template（HTML 模板） HTML a 提供了\u003ctemplate\u003e和\u003cslot\u003e标签，\u003ctemplate标签和其子内容不会在 DOM 中呈现。但仍然可以使用 JS 去引用它。借助这个特性。可以让我们创建一个用来灵活填充 web 组件的模版。 \u003ctemplate id=\"my-paragraph\"\u003e \u003cp\u003eMy paragraph\u003c/p\u003e \u003c/template\u003e 这段代码不会在页面中呈现，但却可以通过document.querySelector() 等 API 获取 let template = document.querySelector('#my-paragraph'); 标签则允许我们在模版中定义占位符，在使用该模版时，该占位符可以填充所需的任何 HTML 标记片段。 通过\u003ctemplate\u003e 标签和插槽\u003cslot\u003e，我们可以将想要的元素定制成一个模版。随取随用。 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:3:0","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"在 web 组件 中使用模版和插槽 \u003cpopup-info\u003e \u003ca href=\"http://www.baidu.com\" slot=\"info\" \u003e一个点击可直接暴富的朴素按钮\u003c/a \u003e \u003cspan slot=\"title\"\u003ebutton\u003c/span\u003e \u003c/popup-info\u003e \u003ctemplate id=\"tooltip-template\"\u003e \u003cstyle\u003e .wrapper { position: relative; top: 100px; left: 10px; } .info { font-size: 14px; width: 200px; display: inline-block; border: 1px solid black; padding: 10px; background: white; border-radius: 10px; opacity: 0; transition: 0.6s all; position: absolute; bottom: 20px; left: 10px; z-index: 3; } .title:hover + .info, .title:focus + .info { opacity: 1; } \u003c/style\u003e \u003cspan class=\"wrapper\"\u003e \u003cspan class=\"title\"\u003e\u003cslot name=\"title\"\u003etitle\u003c/slot\u003e\u003c/span\u003e \u003cspan class=\"info\"\u003e\u003cslot name=\"info\"\u003einfo\u003c/slot\u003e\u003c/span\u003e \u003c/span\u003e \u003c/template\u003e \u003cscript\u003e class PopUpInfo extends HTMLElement { constructor() { super(); const template = document.querySelector('#tooltip-template'); let templateContent = template.content; const shadow = this.attachShadow({ mode: 'open' }); shadow.append(templateContent.cloneNode(true)); } } customElements.define('popup-info', PopUpInfo); \u003c/script\u003e 因为 style 较长，也可以采用 link 标签方式在外部引入 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:3:1","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"Web Component 实践 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:4:0","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"基础组件库 市面上已经有很多基于 Web Components 实现的跨框架 UI 组件库。 它可以同时在任意框架或无框架中使用。 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:4:1","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"Svelte scelte 是目前比较火的前端框架，他有一个特点就是可以自定义组件转成通用的 web 组件（web component）。在多团队协同完成的大项目中，各个团队可能使用不同的框架版本，甚至不同的框架，这让不同项目之间的组件复用变得困难。这种情况下 Svelte 就变成了沟通跨越框架鸿沟的桥梁，使用 Svelte 开发的无框架依赖的 Web Components，可以在各个框架间复用。 ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:4:2","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"微前端 微前端有几个基本概念： 技术栈无关、应用间隔离、独立开发。目前 Web Components 都符合。在一些微前端方案里就采用了 Web Component 的模式。 … ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:4:3","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"Web Component 的缺点 再日常开发中，难免会遇到需要调整组件内部样式的时候，但由于 shadowDOM 的隔离机制，会导致我们很难去修改内部的样式。 在一些复杂的组件中，数据通信和事件传递存在一定使用成本。 … ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:5:0","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"结语 Web Component 虽早在 11 年就已推出，且一直发展至今。他的潜力有目共睹，但目前还有很长的路要走。 或许在以后，我们将不再依赖第三方框架，直接使用原生技术来开发页面也说不定。 end. ","date":"2023-02-23","objectID":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/:6:0","tags":["前端","学习笔记"],"title":"期待Web Component的未来","uri":"/myblog/%E6%9C%9F%E5%BE%85web-component%E7%9A%84%E6%9C%AA%E6%9D%A5/"},{"categories":["前端"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第 2 天，点击查看活动详情 ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:0:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"前言 之前大致说了下 useRequest hook 的基本功能的实现。但 useRequest 的强大不止于此。它还支持如 loading 状态延时、请求防抖、节流、依赖刷新等功能。不过其实现方式都是通过内置的插件 hook 来进行实现的。这样做既可以保证核心代码的简洁，还能更方便的扩展出更高级的功能。并且还支持用户进行自定义插件。 ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:1:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"正文 ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"如何定义一个插件 可以通过插件 hook 的 ts 定义，看一下怎么定义一个插件： 插件 hook 接收两个参数， fetchInstance: fetch 实例； fetchOptions: useRequest 接收的 options； 支持返回一些回调函数： onBefore： 在请求接口前调用； onRequest： 在请求接口时调用； onSuccess： 在请求接口成功后调用； onError： 在请求接口失败后调用； onFinally： 在请求接口完成后调用； onCancel： 在请求接口取消后调用； onMutate： 在出发 mutate 函数时调用； 插件 hook 可以返回一系列的生命周期函数，使我们可以在接口请求的任意一个时机对 fetchInstance 进行处理。 插件 hook 还支持挂载一个静态方法 onInit()，在 Fetch 创建之前，可以通过 Init 方法进行一些前提处理。得到初始的 state。 const use***plugin = ( fetchInstance, fetchOptions, ) =\u003e { const onBefore = () =\u003e { // 对fetchInstance的状态的处理... } ... return { onBefore, ... } } use***plugin.onInit = (fetchOptions) =\u003e { ... } export default use***plugin ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:1","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"插件的使用 插件 hook 一般用来处理 Fetch 实例的状态，在 Fetch 实例被创建之前，会先执行所有插件可能存在的 onInit 方法，该方法会返回 initData，用来初始化 Fetch 实例。 在 Fetch 实例被初始化后，执行所有的插件 hooks，此时，会得到一个包含（onBrfore、onSuccess…）的数组。并将这些方法挂载到 fetchInstance 上。方便在各个时机使用。 const useRequestImplement = ( service: Promise\u003cany\u003e, options, plugins: Array\u003cPlugin\u003e ) =\u003e { // const { manual = false, ...rest } = options; // const fetchOptions = { // manual, // ...rest, // }; // const serviceRef = useLatest(service); // const update = useUpdate(); const fetchInstance = useCreation(() =\u003e { // 在Filter方法中的Boolean可以当成一个转换函数，用来筛选掉空的initData。 const initState = plugins .map((p) =\u003e p?.onInit?.(fetchOptions)) .filter(Boolean); // 将初始化的initState传给构造函数Fetch。 return new Fetch( serviceRef, fetchOptions, update, Object.assign({}, ...initState) ); }, []); // fetchInstance.options = fetchOptions; // 执行所有插件hook，并将其挂载到fetchInstance上。 fetchInstance.pluginImpls = plugins.map((p) =\u003e p(fetchInstance, fetchOptions) ); // useMount(() =\u003e { // // useCachePlugin can set fetchInstance.state.params from cache when init // const params = fetchInstance.state.params ?? []; // // @ts-ignore // fetchInstance.runAsync(...params); // }); // useUnmount(() =\u003e { // fetchInstance.cancel(); // }); // return { // loading: fetchInstance.state.loading, // data: fetchInstance.state.data, // error: fetchInstance.state.error, // params: fetchInstance.state.params || [], // cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)), // }; }; export default class Fetch\u003cTData, TParams extends any[]\u003e { // public count: number = 0; // // public state = { // loading: false, // params: undefined, // data: undefined, // error: undefined, // }; public pluginImpls: Array\u003cPluginReturn\u003e constructor( public serviceRef, public options, public subscribe, public initState ) { this.state = { ...this.state, loading: !options.manual, ...initState, //在constructor时会讲插件初始化生成的状态更新到state中。 }; } // setState(s) { // this.state = { // ...this.state, // ...s, // }; // this.subscribe(); // } // 插件处理函数，会批量执行某个生命周期的函数。并返回处理后的状态。 runPluginHandler(event: keyof PluginReturn, ...rest: any[]) { // @ts-ignore const r = this.pluginImpls.map((i) =\u003e i[event]?.(...rest)).filter(Boolean); return Object.assign({}, ...r); } // async runAsync(...params: TParams): Promise\u003cany\u003e { // this.count += 1; // const currentCount = this.count; // 执行所有插件hooks返回的‘onBefore’方法，并根据返回的state进行相应的处理 const { stopNow = false, returnNow = false, ...state } = this.runPluginHandler('onBefore', params); if (stopNow) { return new Promise(() =\u003e {}); } // // this.setState({ // loading: true, // params, ...state, // }); // // this.options.onBefore?.(params); // try { // const servicePromise = this.serviceRef.current(...params); // const res = await servicePromise; // if (currentCount !== this.count) { // return new Promise(() =\u003e {}); // } // this.setState({ // data: res, // error: undefined, // loading: false, // }); // // this.options.onSuccess?.(res, params); // this.options.onFinally?.(params, res, undefined); this.runPluginHandler('onSuccess', res, params); if (currentCount === this.count) { this.runPluginHandler('onFinally', params, res, undefined); } // // return res; // } catch (error) { // if (currentCount !== this.count) { // // prevent run.then when request is canceled // return new Promise(() =\u003e {}); // } // this.setState({ // error, // loading: false, // }); // // this.options.onError?.(error, params); // this.options.onFinally?.(params, undefined, error); this.runPluginHandler('onError', error, params); if (currentCount === this.count) { this.runPluginHandler('onFinally', params, undefined, error); } // throw error; // } // } // cancel() { // this.count += 1; // this.setState({ // loading: false, // }); this.runPluginHandler('onCancel'); // } // // refreshAsync() { // // @ts-ignore // return this.runAsync(...(this.state.params || [])); // } // run(...params: TParams) { // this.runAsync(...params).catch((error) =\u003e { // if (!this.options.onError) { // console.error(error); // } // }); // } // refresh() { //","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:2","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"Loading Delay useRequest 有个 loading delay 的功能，通过设置 options.loadingDelay ，可以延迟 loading 变成 true 的时间，有效防止闪烁。 这个内置 hook 插件用来控制 loading 状态的延迟。 const { loading, data } = useRequest(getUsername, { loadingDelay: 300 }); return \u003cdiv\u003e{ loading ? 'Loading...' : data }\u003c/div\u003e 例如上面的场景，假如 getUsername 在 300ms 内返回，则 loading 不会变成 true，避免了页面展示 Loading… 的情况。 我们可以尝试着通过插件 hook 的方式来实现一下。默认情况下，loading 状态在接口 onBefore 的时候会被更新成 true。那我们就需要在接口 onBefore 的时候，将其改为 false，并加一个定时器，让其在指定时间之后再变为 true： import { useRef } from 'react'; import type { Plugin, Timeout } from '../types'; const useLoadingDelayPlugin: Plugin\u003cany, any[]\u003e = (fetchInstance, { loadingDelay }) =\u003e { const timerRef = useRef\u003cTimeout\u003e(); // 用户没有设置loadingDelay时直接返回 if (!loadingDelay) { return {}; } // 取消定时器。 const cancelTimeout = () =\u003e { if (timerRef.current) { clearTimeout(timerRef.current); } }; return { // 更改loading的状态为false，并加个定时器，让其在指定的delay时间后在更正为true。 onBefore: () =\u003e { cancelTimeout(); timerRef.current = setTimeout(() =\u003e { fetchInstance.setState({ loading: true, }); }, loadingDelay); return { loading: false, }; }, // 在请求完成或取消时，记得销毁定时器。 onFinally: () =\u003e { cancelTimeout(); }, onCancel: () =\u003e { cancelTimeout(); }, }; }; export default useLoadingDelayPlugin; … ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:3","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"ready 和 refreshDeps useRequest 支持 ready 配置，当 options 中的 ready 值为 false 时，请求永远都不会发出。其具体行为如下： 当 manual=false 自动请求模式时，每次 ready 从 false 变为 true 时，都会自动发起请求，会带上参数 options.defaultParams。 当 manual=true 手动请求模式时，只要 ready=false，则通过 run/runAsync 触发的请求都不会执行。 支持依赖刷新，当 options 中的 refreshDeps 值变化后，会重新触发请求。 由于这两个需要类似，可以放在一个 hook 里实现 import { useRef } from 'react'; import useUpdateEffect from '../../../useUpdateEffect'; import type { Plugin } from '../types'; // support refreshDeps \u0026 ready const useAutoRunPlugin: Plugin\u003cany, any[]\u003e = ( fetchInstance, { manual, ready = true, defaultParams = [], refreshDeps = [], refreshDepsAction, } ) =\u003e { // 避免重复请求的ref。 const hasAutoRun = useRef(false); hasAutoRun.current = false; // 在自动模式（manual === false）且ready === true时发送请求。 useUpdateEffect(() =\u003e { if (!manual \u0026\u0026 ready) { hasAutoRun.current = true; fetchInstance.run(...defaultParams); } }, [ready]); // 在自动模式下，当refreshDeps发生变化，会出发refresh事件。 useUpdateEffect(() =\u003e { if (hasAutoRun.current) { return; } if (!manual) { hasAutoRun.current = true; fetchInstance.refresh(); } }, [...refreshDeps]); return { // 在请求前判断ready状态，等于true才能发送请求。 onBefore: () =\u003e { if (!ready) { return { stopNow: true, }; } }, }; }; // 还有一个onInit事件，初始化loading的状态，在自动模式且ready为true时状态才为true。 useAutoRunPlugin.onInit = ({ ready = true, manual }) =\u003e { return { loading: !manual \u0026\u0026 ready, }; }; export default useAutoRunPlugin; … 其他插件大同小异，可以前往 ahooks 仓库查看https://github.com/alibaba/hooks/tree/master/packages/hooks/src/useRequest/src/plugins end. ","date":"2022-11-26","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/:2:4","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（下）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8B/"},{"categories":["前端"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"开启掘金成长之旅！这是我参与「掘金日新计划 · 12 月更文挑战」的第 1 天，点击查看活动详情 ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:0:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"前言 useRequest 是一个异步数据管理的 hooks，是 ahooks Hooks 库的核心 hook，因为其通过插件式组织代码，大部分功能都通过插件的形式来实现，所以其核心代码行数较少，简单易懂，还可以支持我们自定义扩展功能。可以说，useRequest 能处理 React 项目绝大多数的网络请求场景。 让咱自己写可能写不出来，那就先从模仿开始，通过阅读 useRequest 的代码，从中学习大佬们的代码逻辑和思维处理。 ahooks： https://ahooks.js.org/ 文中代码基于 3.7.2 版本 ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:1:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"前置 hook 了解 在 useRequest 的源码实现中使用到了一些其他的 hooks useCreation：useMemo 或 useRef 的替代品。 useLatest：返回当前最新值的 Hook， 可以避免闭包问题。 useMemoizedFn：useCallback 的替代品 。 useMount：只在组件初始化时执行的 Hook。 useUnmount：在组件卸载（unmount）时执行的 Hook。 useUpdate：强制组件重新渲染的 hook。 ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:2:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"实现最基础的 useRequest Hook const { data, error, loading, cancel } = useRequest(service); useRequest 通过定义一个 class 类 Fetch 来维护相关的数据（data，loading 等）和方法（run， refresh 等）然后在 useRequestImplement 中创建 Fetch 实例，并返回实例属性和方法。 我对代码进行了拆分，保留了 useRequest 中核心的功能，该 hook 接收一个 promise，需要返回 data、error、loading、cancel 状态。 const useRequestImplement = (service: Promise\u003cany\u003e) =\u003e { const serviceRef = useLatest(service); const update = useUpdate(); const fetchInstance = useCreation(() =\u003e { return new Fetch(serviceRef, update); }, []); useMount(() =\u003e { // useCachePlugin can set fetchInstance.state.params from cache when init const params = fetchInstance.state.params ?? []; // @ts-ignore fetchInstance.runAsync(...params); }); useUnmount(() =\u003e { fetchInstance.cancel(); }); return { loading: fetchInstance.state.loading, data: fetchInstance.state.data, error: fetchInstance.state.error, params: fetchInstance.state.params || [], cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)), }; }; export default class Fetch\u003cTData, TParams extends any[]\u003e { public count: number = 0; public state = { loading: false, params: undefined, data: undefined, error: undefined, }; constructor(public serviceRef, public subscribe) {} setState(s) { this.state = { ...this.state, ...s, }; this.subscribe(); } async runAsync(...params: TParams): Promise\u003cany\u003e { this.count += 1; const currentCount = this.count; this.setState({ loading: true, params, }); try { const servicePromise = this.serviceRef.current(...params); const res = await servicePromise; if (currentCount !== this.count) { return new Promise(() =\u003e {}); } this.setState({ data: res, error: undefined, loading: false, }); return res; } catch (error) { if (currentCount !== this.count) { // prevent run.then when request is canceled return new Promise(() =\u003e {}); } this.setState({ error, loading: false, }); throw error; } } cancel() { this.count += 1; this.setState({ loading: false, }); } refreshAsync() { // @ts-ignore return this.runAsync(...(this.state.params || [])); } } ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:3:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"实现剩余核心功能 接收用户的自定义配置，包括 manual(手动模式)和一些回调函数（onBefore,onSuccess, onError,onFinally） const useRequestImplement = (service: Promise\u003cany\u003e, options) =\u003e { const { manual = false, ...rest } = options; const fetchOptions = { manual, ...rest, }; // const serviceRef = useLatest(service); // const update = useUpdate(); // const fetchInstance = useCreation(() =\u003e { return new Fetch(serviceRef, fetchOptions, update); // }, []); fetchInstance.options = fetchOptions; useMount(() =\u003e { if (!manual) { const params = fetchInstance.state.params || options.defaultParams || []; // @ts-ignore fetchInstance.run(...params); } }); // useUnmount(() =\u003e { // fetchInstance.cancel(); // }); return { // loading: fetchInstance.state.loading, // data: fetchInstance.state.data, // error: fetchInstance.state.error, // params: fetchInstance.state.params || [], // cancel: useMemoizedFn(fetchInstance.cancel.bind(fetchInstance)), refresh: useMemoizedFn(fetchInstance.refresh.bind(fetchInstance)), refreshAsync: useMemoizedFn(fetchInstance.refreshAsync.bind(fetchInstance)), run: useMemoizedFn(fetchInstance.run.bind(fetchInstance)), runAsync: useMemoizedFn(fetchInstance.runAsync.bind(fetchInstance)), mutate: useMemoizedFn(fetchInstance.mutate.bind(fetchInstance)), }; }; export default class Fetch\u003cTData, TParams extends any[]\u003e { // public count: number = 0; // // public state = { // loading: false, // params: undefined, // data: undefined, // error: undefined, // }; constructor(public serviceRef, public options, public subscribe) { this.state = { ...this.state, loading: !options.manual, }; } // setState(s) { // this.state = { // ...this.state, // ...s, // }; // this.subscribe(); // } // async runAsync(...params: TParams): Promise\u003cany\u003e { // this.count += 1; // const currentCount = this.count; // // this.setState({ // loading: true, // params, // }); // this.options.onBefore?.(params); // try { // const servicePromise = this.serviceRef.current(...params); // const res = await servicePromise; // if (currentCount !== this.count) { // return new Promise(() =\u003e {}); // } // this.setState({ // data: res, // error: undefined, // loading: false, // }); // this.options.onSuccess?.(res, params); this.options.onFinally?.(params, res, undefined); // // return res; // } catch (error) { // if (currentCount !== this.count) { // // prevent run.then when request is canceled // return new Promise(() =\u003e {}); // } // this.setState({ // error, // loading: false, // }); // this.options.onError?.(error, params); this.options.onFinally?.(params, undefined, error); // throw error; // } // } // cancel() { // this.count += 1; // this.setState({ // loading: false, // }); // } // // refreshAsync() { // // @ts-ignore // return this.runAsync(...(this.state.params || [])); // } run(...params: TParams) { this.runAsync(...params).catch((error) =\u003e { if (!this.options.onError) { console.error(error); } }); } refresh() { // @ts-ignore this.run(...(this.state.params || [])); } mutate(data?: TData | ((oldData?: TData) =\u003e TData | undefined)) { const targetData = isFunction(data) ? data(this.state.data) : data; this.setState({ data: targetData, }); } } runAsync 和 run runAsync 方法返回一个 promise，使用 runAsync 时，当请求报错会中断后续操作，需要手动捕获异常。 run 方法则对 runAsync 进行了封装，帮助我们了捕获异常，或可以通过 options.onError 来处理异常行为。 refresh 和 refreshAsync useRequest 维护了一份 params，调用 run()和 runAsync()的时候会同时更新 params。以便给 refresh 和 refreshAsync 方法使用 cancel useRequest 维护了一个 count。 而 runAsync 方法本身也维护一个 currentCount。 每次调用 runAsync 时，count 进行一次++操作，然后将其赋值给 currentCount。 每次 cancel 方法 count 会再进行一次++操作。通过比较 count 和 currentCount 的值来判断用户是否进行了取消操作，进行相应的处理 mutate 支持立即修改 useRequest 返回的 data 参数。 mutate 的用法与 React.setState 一致，支持 mutate(newData) 和 mutate((oldData) =\u003e newData) 两种写法。 ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:4:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"小结 以上是 useRequest hook 的基本功能，剩余功能如 loading 状态延时、请求防抖、节流、数据缓存等功能都是通过插件的形式进行实现的，具体实现可以看 ahooks 中的核心 hook-useRequest（下） ","date":"2022-11-23","objectID":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/:5:0","tags":["react","hooks"],"title":"ahooks中的核心hook-useRequest（上）","uri":"/myblog/ahooks%E4%B8%AD%E7%9A%84%E6%A0%B8%E5%BF%83hook-userequest%E4%B8%8A/"},{"categories":["前端"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-10-23","objectID":"/myblog/react-router-v6/","tags":["react","学习笔记"],"title":"react-router v6","uri":"/myblog/react-router-v6/"},{"categories":["前端"],"content":"前言 之前一直负责老项目的迭代，而且很少关注 router 相关的代码，直到上个月公司开了一个新项目，当我着手开始配置路由时突然发现，嗯？Switch 标签咋没了？Route 里的 component 属性咋也没了。意识到不妙的我赶紧去翻了翻 react router 的文档，发现 react router 早就在 21 年底就偷偷升级到了 v6 且变更极大（嗯 这是一个悲伤的故事，现在甚至已经更新到了 6.4.1） 之前的老项目的包版本是 5.2 的，要升级的话成本有点高，也懒得搞，就那样吧。但新项目肯定不能将就啊。那就整呗 ","date":"2022-10-23","objectID":"/myblog/react-router-v6/:0:1","tags":["react","学习笔记"],"title":"react-router v6","uri":"/myblog/react-router-v6/"},{"categories":["前端"],"content":"正文 首先先说一下 react-router 和 react-router-dom 的区别，react-router 实现了路由的核心功能，react-router-dom 则是基于 react-router，又加了在浏览器运行环境下的一些功能，比如把 Link 组件渲染成一个 a 标签，再比如 HashRouter 会使用 window.location.hash 和 hashChange 事件构建路由。一般在项目中只需要引入 react-router-dom 包即可。 npm install react-router-dom BrowserRouter 新项目使用浏览器路由即 BrowserRouter，要想在项目中使用 React Router，需要 App 组件嵌套进 BrowserRouter 组件中。 ReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement).render( \u003cReact.StrictMode\u003e \u003cBrowserRouter\u003e \u003cApp /\u003e \u003c/BrowserRouter\u003e \u003c/React.StrictMode\u003e ); Routes 和 Route 我们使用 Route 组件来定义路由，并使用 Routes 包裹。 Route 组件接收两个 props： path?: string | 页面 url element?： React.ReactNode |当前 url 需要加载的元素 \u003cRoutes\u003e \u003cRoute path=\"/\" element={\u003cHome /\u003e} /\u003e \u003cRoute path=\"/teams/:id\" element={\u003cTeams /\u003e} /\u003e \u003cRoute path=\"/teams/new\" element={\u003cNewTeams /\u003e} /\u003e \u003cRoute path=\"*\" element={\u003cPageError /\u003e} /\u003e \u003c/Routes\u003e \u003cSwitch\u003e \u003cRoute path=\"/teams/:id\" component={Teams} /\u003e \u003cRoute path=\"/teams/new\" component={NewTeams} /\u003e \u003c/Switch\u003e V6 的 Route 组件不在要求我们按一定的顺序来定义路由,在旧版本中，当多个路由匹配一个模糊的 url 时，我们必须以某种方式对路由进行排序，v6 版本则会替我们选择最具体的匹配。/teams/new 将匹配这两个路由，但只会渲染 NewTeams 组件。 支持的格式： /groups /groups/admin /users/:id /users/:id/messages /files/* /files/:id/* 嵌套路由 react-router V6 支持路由的嵌套，允许父路由控制子路由的渲染， 提供了一个渲染出口组件 Outlet，当匹配到子路由的时候会渲染在 Outlet 组件所在的位置，父路由此时仍然存在。 支持多级嵌套 const src = () =\u003e { return ( \u003c\u003e \u003cRoutes\u003e \u003cRoute path=\"/\" element={\u003cHome /\u003e} /\u003e \u003cRoute path=\"/list\" element={\u003cList /\u003e}\u003e \u003cRoute path=\"Detail/:id\" element={\u003cDetail /\u003e} /\u003e \u003c/Route\u003e \u003c/Routes\u003e \u003c/\u003e ) } const List = () =\u003e { const navigate = useNavigate(); return ( \u003c\u003e \u003cdiv className=\"list\"\u003e \u003cButton onClick={() =\u003e { navigate('/list/detail/1'); }} \u003e detail1 \u003c/Button\u003e \u003cButton onClick={() =\u003e { navigate('/list/detail/2'); }} \u003e detail2 \u003c/Button\u003e // react-router提供了Outlet组件用来占位置 \u003cOutlet /\u003e \u003c/div\u003e \u003c/\u003e ); 查询参数 /mysql?mysql_group_id=mysql-test\u0026mysql_instance_id=mysql-asfasfew react-router V6 提供了 useSearchParams Hook，它是基于浏览器内置的 URLSearchParams 构造函数进行的封装。 useSearchParams 类似 useState，返回一个数组，第一个元素是一个 Map，可以通过其 get 方法获取查询字符串中的值，第二个元素是一个函数，用来更新 url 中的查询字符串。 import { useSearchParams } from 'react-router-dom'; const [searchParams, setSearchParams] = useSearchParams(); const groupId = searchParams.get('mysql_group_id') const instanceId = searchParams.get('mysql_instance_id') const updateOrder = (sort) =\u003e { setSearchParams({ key: value }) } 编程式配置路由 react-router V6 还提供了 useRoutes Hook，使我们可以通过写一个配置对象的方式来配置路由，不需要在自行拼接 jsx. const routerConfig = [ { path: \"/\", key: \"home\", label: \"common.nav.menu.home\", icon: \u003cHomeOutlined /\u003e, element: \u003cHome /\u003e, }, { key: \"authManageWrapper\", label: \"common.nav.menu.authManage\", icon: \u003cSolutionOutlined /\u003e, children: [ { path: \"/auth/list\", key: \"authList\", label: \"common.nav.menu.authList\", element: \u003cAuthList /\u003e, }, { path: \"/auth/add\", key: \"addAuth\", label: \"common.nav.menu.addAuth\", element: \u003cAddAuth /\u003e, }, ], }, { path: \"*\", hideInMenu: true, key: \"null\", element: \u003cNavigate to=\"/\" /\u003e, }, ] return ( \u003c\u003e {useRoutes(routerConfig)} \u003c/\u003e ) 在 antd 的 4.20 版本+中，他的 Menu 导航组件也支持这种写法，可以维护一份 routerConfig，对其扩充一些属性，就能同时再 Menu 组件中使用。 其他 新增 useNavigate Hook 代替 useHistory Hook let navigate = useNavigate(); \u003cbutton onClick={() =\u003e { navigate(\"/invoices\" + location.search); }} \u003e jump \u003c/button\u003e 可以在各个地方渲染多组路由：经常有一些需求让我们在某个 state 为 true 时展示组件 A，为 false 时展示组件 B，这个时候可以尝试在组件内写一个嵌套路由。 总结： 定义路由时 Routes 组件和 Route 组件搭配使用，且可以在不同地方定义多组。Route 组件的属性也发生了变更。 新增了 Outlet 组件，支持路由的嵌套，使用起来可以更加的灵活。 新增了一个可以查询和更新 url 参数的 hook useSearchParams。 提供了 useRoutes Hook， 支持使用 js 对象的形式来定义路由。 ","date":"2022-10-23","objectID":"/myblog/react-router-v6/:0:2","tags":["react","学习笔记"],"title":"react-router v6","uri":"/myblog/react-router-v6/"},{"categories":["前端"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"红宝书（学习笔记） ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"三、语言基础 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"null 和 undefined（3.4） null: 表示一个空对象指针。这也是 typeof null 会返回‘object’的原因。 undefined： undefined 值由 null 派生而来，所以表面相等（null == undefined // true） 当声明了变量但未赋值的时候，就相当于给变量赋值了 undefined； 当访问对象变量中不存在的属性时会返回 undefined； 区别： 在定义一个将要保存对象值得变量来说，可以使用 null 来初始化 但不建议给某个变量设置 undefined 值。字面值 undefined 主要用于比较 （undefined可以用来**读**，null可以用来**读写**） Number(null) return 0; Number(undefined) return NaN ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"Symbol 类型（3.4） 之前没仔细了解过，原来 Symbol 还有几个 api 如果想重用符号实例，可以通过 Symbol.for()方法 const a = Symbol('a'); const b = Symbol('a'); console.log(a == b); //false const c = Symbol.for('a'); const d = Symbol.for('a'); console.log(a == b); //true // 注： const e = Symbol('a'); const f = Symbol.for('a'); console.log(a == b); //false 还可以对其进行查询 const g = Symbol.for('a'); console.log(Symbol.keyFor(g)); // 'a' const h = Symbol('a'); console.log(Symbol.keyFor(h)); // undefined console.log(Symbol.keyFor(123)); // TypeError 123 is not a symbol 当 Symbol 符号作为对象的键的时候，是不会被 Object.keys 或 entries 等相关 api 遍历出来的, 可以通过 Object.getOwnPropertySymbols()等来拿到对象的 symbol 类型键值 const a = Symbol('a'); const b = Symbol('b'); const obj = {}; obj[a] = '123'; obj[b] = '456'; obj['c'] = '789'; console.log(obj); // {c: '789', Symbol(a): '123', Symbol(b): '456'} Object.keys(obj); // ['c']; Object.values(obj); // ['789']; Object.getOwnPropertyNames(obj); // ['c']; Object.getOwnPropertySymbols(obj); // [Symbol(a), Symbol(b)]; Object.getOwnPropertyDescriptors(obj); // [Symbol(a), Symbol(b)]; // 或者通过Reflect.ownKeys()拿到两个类型的键 Reflect.ownKeys(obj); // ['c', Symbol(a), Symbol(b)]; ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"四、变量、作用域与内存 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"原始值与引用值（4.1） 变量可以包含两种类型的数据，原始值和引用值， 原始值就是最简单的数据（string， number，symbol，undefined，null, boolean） 引用值则是由多个值构成的对象。 typeof 可以确认值的原始值类型，instanceof 可以用于确认值的引用类型 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"六、集合引用类型 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"array.form() (6.2.1) Array.form()除了能将类数组结构转换为数组实例外，还能进行类似 map 操作 Array.from()方法有一个可选参数 mapFn，让你可以在最后生成的数组上再执行一次 map 方法后再返回。也就是说` Array.from(obj, mapFn, thisArg) 就相当于 Array.from(obj).map(mapFn, thisArg) ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"八、对象、类与面向对象编程 ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"理解对象（8.1） 对象： 一组属性的无序集合，他的每个属性或方法都有一个名称来标识； 对象的属性有两种类型，数据属性和访问器属性，ECMA 使用了一些内部特性来描述属性的特征 数据属性：数据属性包含一个保存数据值的位置用来读写，他有四个特性 [[Configurable]]: 表示当前属性是否可以通过 delete 删除以及是否可以把它改为访问器属性，默认为 true [[Enumberable]]: 表示属性是否可以通过 for-in 循环返回，默认为 true [[Writable]]: 表示属性值是否支持修改，默认为 true [[Value]]: 包含属性实际的值，默认为 undefined。 let obj = { name: 'Xiaoming' } // 这就意味着obj这个对象的name属性的特性[[Value]]会被设置为'Xiaoming' //可以通过Object.defineProperty()方法来修改属性的默认特性 // Object.defineProperty(objName, attrName, descriptor) // objName: 要修改的对象名称； // attrName: 要修改的对象的属性名称； // descriptor: 要修改的描述符对象(Configurable、Enumberable、Writable、Value)。 const person = {} // 设置只读 Object.defineProperty(person, 'name', { writable: false, value: 'Xiaoming', }) console.log(person.name) // Xiaoming; person.name = 'Xiaohong' console.log(person.name) // Xiaoming; // 设置不可删除 Object.defineProperty(person, 'name', { configurable: false, }) delete person.name; console.log(person.name) // Xiaoming; 访问器属性: 访问器属性不包含数据值，相反，他们包含一个获取函数（getter）和设置函数（setter），在读取访问器属性时，会调用获取函数，在写入访问器属性时会调用设置函数。同样他也有 4 个特性来描述他的行为: [[Configurable]]: 表示当前属性是否可以通过 delete 删除以及是否可以把它改为访问器属性，默认为 true [[Enumberable]]: 表示属性是否可以通过 for-in 循环返回，默认为 true 【注】访问器属性是不能直接定义的，必须使用 Object.defineProperty() const person { age_: 28, } Object.definedProperty(person, 'age', { get() { return this.age_ + 1; } set(newValue) { this.age_ = newValue * 2; } }) console.log(person.age_) // 28; console.log(person.age) // 29; person.age = 10; console.log(person.age_) // 20; console.log(person.age) // 21; // 获取函数和设置函数不一定都要定义，只设置获取函数意味着属性是只读的，只设置设置函数的属性意味着属性不能进行读取 可以通过 Object.getOwnPropertyDescriptor(objName, attrName?: string)方法来取得指定属性的属性描述符 const person = {name: 'Xiaoming'} console.log(Object.getOwnDefinePropertyDescriptor(person, 'name')) // { // configurable: true, // enumerable: true, // writable: true, // value: 'Xiaoming', //} ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"对象标识及相等判定（8.1.5） 除了能通过 isNaN（）来判断变量是否是 NaN，还可以通过 Object.is(); console.log(NaN === NaN) // false; console.log(isNaN(NaN)) // true; console.log(Object.is(NaN, NaN)) // true; ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["前端"],"content":"判断对象中是否包含某个属性 // 判断对象实例或原型是否包含某个实例 const obj = {name: 'xiaoMing'}; console.log('name' in obj) // true; console.log('age' in obj) // false; //判断对象实例是否包含某个实例 function Person(){}; Person.prototype.name = 'xiaoMing'; let son = new Person(); console.log(son.name) // 'xiaoMing; console.log(son.hasOwnProperty('name')) // false; ","date":"2022-01-10","objectID":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","tags":["javascript","学习笔记"],"title":"js高程学习笔记","uri":"/myblog/js%E9%AB%98%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"排序的分类 时间复杂度（O(n^2)）: 冒泡、插入、选择； 时间复杂度（O(nLogn)）: 快排，归并； 时间复杂度（O(n)）: 桶，计数，基数； ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"如何分析一个排序算法 ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"执行效率（时间复杂度）： 最好情况、最坏情况、平均情况； 时间复杂度的系数、常数、低阶：时间复杂度反映的是数据规模 n 很大的时候的增长趋势，所以他会忽略掉系数、常数和低阶。但实际开发中，面对一些规模很小的数据时，为了相对精确的比较不同算法的执行效率，就需要把系数、常数、低阶也考虑进去。 ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:2:1","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"内存消耗（空间复杂度）； ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:2:2","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"稳定性：指的是如果在待排序的序列中存在值相等的元素，经过排序后，相等元素之间的顺序是否发生变化 ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:2:3","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"冒泡排序 从下标 0 开始，对相邻的数据进行比较，不满足条件则互换位置。 一轮冒泡会让至少一个元素移动到他应该在的位置。重复 n 次。就完成了 n 个数据的排序。 {% img /images/bubbling.webp %} 可以看到，经过一次排序后，6 已经挪到了末尾。执行 6 次后，排序完成。 两个优化点： 当某一轮冒泡期间，没有数据交换的操作，意味着已经达到完全有序，就无须在进行后续的冒泡操作了。 每一轮冒泡后，都会至少确认一个元素的位置于末尾。因此，每轮冒泡相对于上一轮都可以少比较一次。（如图例，第一轮冒泡需要比较 6 个元素，第二轮则只需要比较前 5 个元素） // 冒泡排序 const bobbleSort = (arr) =\u003e { if (arr.length \u003c= 1) return arr; for(let i = 0; i \u003c arr.length; i++) { let flag = true; for(let j = 0; j \u003c arr.length - i; j++) { if (arr[j] \u003e arr[j + 1]) { let temp = arr[j]; arr[j] = arr[j + 1]; arr[j] = temp; flag = false; } } if (flag) break; } } ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:3:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"插入排序 首先将数组中的数据分为两个区间，已排序区间和未排序区间。（初始，已排序区间只有一个元素如第一个元素） 插入排序的核心思想： 遍历未排序区间的元素，在已排序区间中找到合适的位置，插入进去，并保证已排序区间一直有序。知道未排序区间中的元素为空。 {% img /images/insertionSort.webp %} 把数据 a 插入已排序区间：需要拿 a 与已排序区间的元素依次进行比较，找到合适的位置插入进去。 // 插入排序 const insertionSort = (arr) =\u003e { if (arr.length \u003c= 1) return; // 1. 遍历未排序区间的元素。 for (let i =1; i\u003c arr.length; i++) { // 2. 当前要进行比较插入的未排序区间元素 let value = a[i]; // 3. value元素的上一个元素下标。 let j = i - 1; // 4. 从 下标j开始，往下标0依次进行比较，直到找到value应该插入的位置 for(; j \u003e= 0; j--) { if（arr[j] \u003e value）{ arr[j + 1] = arr[j]; } else { break; } } //插入数据value； arr[j + 1] = value; } } ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:4:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"选择排序 类似于插入排序，也有已排序区间和未排序区间，已排序区间默认为空， 在未排序区间找到最小值，插入已排序区间的末尾； // 选择排序 const selectionSort = (arr) =\u003e { if (arr.length \u003c= 1) return; for (let i = 0; i \u003c arr.length; i++) { let minIndex = i; for (let j = i+1; j\u003c arr.length; j++) { minIndex = arr[minIndex] \u003c arr[j] ? minIndex : j; } const temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } console.log(arr); return arr; } ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:5:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"比较冒泡排序和插入排序 冒泡排序的数据交换比插入排序的数据移动要复杂，冒泡排序需要三个赋值操作，而插入排序只需要一个 // 冒泡排序 if（a[j] \u003e a[j + 1]） { let temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; }; //插入排序 if (a[j] \u003e value) { a[j + 1] = a[j]; } else { break; }; 总结： {% img /images/sortSummary.webp %} ","date":"2022-01-08","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/:6:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（五）排序","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%94%E6%8E%92%E5%BA%8F/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"递归 描述： 一种非常高效、简洁的编程技巧。函数调用自身的方式称为递归调用，调用成为递，返回称为归； 正确姿势：找到如何将大问题分解为小问题的规律，并基于此写出递推公式。然后再敲定终止条件，生成递归函数。 ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:0:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"优缺点： 优点：代码简洁，表达力强 缺点： 空间复杂度高，有堆栈溢出风险、存在重复计算、过多函数调用会耗时较多等问题。 ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"递归需要满足的三个条件： 一个人问题的解可以分解为几个子问题（数据规模更小的问题）的解； 这个问题与分解后的子问题，除了数据规模不同，求解思路完全一样； 存在递归终止条件：把问题分解为子问题，把子问题再分解为子子问题，一层层分解下去，这就需要一个终止条件，防止无限分解； ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"练习题： 假设有 n 个台阶，每次你可以跨一个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？ 提示： 如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，2，1 这样子上去。 解： 我们可以根据 第一步 的走法把所有走法分为两类， 第一类是第一步走了 1 个台阶 第二类是第一步走了 2 个台阶 所以，n 个台阶的走法 = 先走 1 个台阶后，n-1 个台阶的走法 + 先走 2 个台阶后，n-1 个台阶的走法。 得到求解公式： f(n) = f(n-1) + f(n-2) 找到终止条件： 当有一个台阶时，只有一个走法，结束递归，f(1) = 1；当有两个台阶时，有两个走法，结束递归，f(2）= 2； 通过求解公式和终止条件，可以得到一个递归函数求出所有走法的总数 const func = (num) =\u003e { if (n === 1) return 1; if (n === 2) return 2; return f(n-1) + f(n-2); } ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:3:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"技巧 如果一个问题 A 可以分解为若干个子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。屏蔽掉递归细节，把它抽象成一个递推公式，不要想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。 ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:4:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"递归的问题： 要警惕堆栈溢出：函数调用会使用栈来保存临时变量每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈，系统栈和虚拟机栈空间一般都不大，如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。 解决：尽可能的限制递归深度和运算的复杂度 要警惕重复计算：如果把上题的递归过程拆解，如下图： {% img /images/recursion.webp %} 我们可以直观的看到，想要计算 f(5)，需要先计算 f(4)和 f(3)，而计算 f(4)同样需要计算 f(3)，因此，f(3)就被计算了很多次，这就是重复计算问题。 解决：可以将求解过的 f(k)保存起来，当递归调用到 f(k)时先看下是否已经求解过了，是则直接取值返回。 const returnList = {}; const func = (num) =\u003e { if (n === 1) return 1; if (n === 2) return 2; if (returnList[n]) { return rerutnList[n] } const val = f(n-1) + f(n-2) returnList[n] = val; return val; } 要警惕无限递归问题： 解决： 一定要保证终止条件是有效且合理的， ","date":"2022-01-07","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/:5:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（四）递归","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%9B%E9%80%92%E5%BD%92/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-06","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（三）栈与队列","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"栈 栈是一种操作受限的线性表，只允许在一端插入（push()）和删除（pop()）数据。 特性： 后进者先出，先进者后出 使用场景： 如浏览器的前进、后退功能 ","date":"2022-01-06","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:0:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（三）栈与队列","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"使用数组实现一个简易的栈结构 class CreateStack { private stack: any[] = []; public push(item: any) { this.stack.push(item); return true; } public pop() { if (this.stack.length === 0) { return null; } const tmp = this.stack[this.stack.length - 1]; this.stack.pop(); return tmp; } } 队列 队列和栈非常的相似，最基本的操作也是两个： 入队（enqueue()），放一个数据到队列的尾部，出队（dequeue()）,从队头取出一个数据。 特性： 先进先出。 ","date":"2022-01-06","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（三）栈与队列","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"使用数组实现一个简易的队列结构 class CreateStack { private stack: any[] = []; private headIndex: number = 0； public enqueue(item: any) { this.stack.push(item); return true; } public dequeue() { if (this.stack.length === headIndex) { return null; } const tmp = this.stack[headIndex]; ++headIndex; return tmp; } } ","date":"2022-01-06","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（三）栈与队列","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"数组 数组是一种线性表数据结构，用一组连续的内存空间来存储数据 线性表： 线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向， 其他线性表数据结构：链表、队列、栈。 {% img /images/LinearTable.webp %} 非线性表： 数据之间不是简单的前后关系 {% img /images/NotLinearTable.webp %} 链表 与数组不同， 他并不需要一块连续的内存空间，他可以通过指针将一组零散的内存块串联起来使用。 {% img /images/LinkedList.webp %} 最常见的三种链表结构： 单链表，双向链表，循环链表。 ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:0:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"单链表 链表通过指针将一串零散的内存块串联在一起，其中，内存块称为链表的节点，为了把所有的节点串起来，每个链表的节点除了存储数据外，还需要记录下一个链表的地址，我们把这个记录下个节点地址的指针叫做后继指针 next {% img /images/SingleLinkedList.webp %} 头节点和尾节点两个节点比较特殊， 头结点用来记录链表的基地址，有了它，就可以遍历得到整条链表。 尾结点则指向一个空地址 null，表示这是链表的最后一个节点。 {% img /images/LinkedListAction.webp %} ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"循环链表 循环链表是特殊的单链表，和单链表的区别就在于尾结点，循环链表的尾结点指向链表的头结点 {% img /images/CircularLinkedList.webp %} ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"双向链表 单链表只有一个方向，节点只有一个后继指针 next 指向后面的节点，双向链表则多了一个前驱指针 prev 指向前面的节点，支持双向遍历，增加了灵活性。 同样的，既然多出一个空间用来存储前驱节点，所以，当存储同样多的数据时，双向链表要比单链表占据更多的内存空间 {% img /images/BidirectionalLinkedList.webp %} ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:3:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"链表的相关操作 ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:4:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"插入节点 // 将节点插入到node后面 new_node-\u003enext = node-\u003enext node = new_node ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:4:1","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"删除节点 // 删除节点node的后继节点 node-\u003enext = node-\u003enext-\u003enext 总结： 数组和链表的区别： 存储结构： 数组： 连续的内存空间；可以借助 CPU 的缓存机制，预读数组中的数据，访问效率更高。 链表： 一组零散的内存块；对 CPU 缓存不友好，没办法有效预读。 插入，删除操作的复杂度： 数组： 数组结构的在进行插入、删除操作时，为了保证整体的连续性，需要做大量的数据迁移，时间复杂度为 O(n)。 链表： 链表的存储空间本身就是不连续的，只需要关注考虑相邻接点的指针改变，总时间复杂度是 O(1)。 （延伸：尽管单纯的删除操作， 时间复杂度是 O(1)，但删除某个节点 q，需要知道上一个节点的地址，单链表寻找上一个节点仍需遍历查找，时间复杂度为 O(n)，总时间为找+删=O(n)；） 随机访问： 数组： 可以通过下标计算出对应的内存地址，时间复杂度为 O(1)。 链表： 因为链表数据不是不是连续储存的，所以无法像数组一样根据首地址和下标计算出对应的内存地址，只能通过指针一个个节点进行遍历的方法寻找相应的节点。链表的每个节点都只知道自己的下一个节点的地址，当我们想知道第 k 个节点的时候，只能从第一个开始往下数，时间复杂度是 O(n)。 ","date":"2022-01-04","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/:4:2","tags":["数据结构与算法","学习笔记"],"title":"数据结构（二）数组与链表","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8/"},{"categories":["数据结构与算法"],"content":"这篇文章展示了基本的 Markdown 语法和格式.","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["数据结构与算法"],"content":"开头 好记性不如烂笔头，在这里记录下学习数据结构与算法之美的笔记 ","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:1:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["数据结构与算法"],"content":"简述 数据结构指的是‘一组数据的存储结构’，算法指的是’操作数据的一种方法‘。 数据结构是为算法服务的，算法要作用在特定的数据结构之上。 ","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:2:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["数据结构与算法"],"content":"正片 ","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:0","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":["数据结构与算法"],"content":"复杂度分析 时间复杂度 （大 O 复杂度表示法） 算法的执行效率，粗略的讲，就是算法代码的执行时间。 const (n) =\u003e { const sum = 0; const i = 1; for (; i \u003c= n; ++i) { sum = sum + i; }; return sum } 假设每行代码执行的时间都一样，为 o,那么 第 2, 3 行分别需要一个 o 的执行时间； 第 4, 5 行都运行了 n 次，所以需要 2 个 n* o 的执行时间； 这段代码的总执行时间就是：（2n + 2）* o。 可以看出，每行代码的执行次数越多，总执行时间 T(n)就越高。按照这个思路，再看一段代码 const (n) =\u003e { const sum = 0; const i = 1; for (; i \u003c= n; ++i) { const j = 1; for (; j \u003c= n; ++j) { sum = sum + i + j; } }; return sum } 第 2、3、5 行需要一个 o 的执行时间； 第 4、5 行执行了 n 遍，需要 2 个 n * o 的执行时间； 第 7、8 行执行了 n^2 遍，需要 2 个 n^2 * o 的执行时间； 总执行时间为(2n^2 + 2n + 3) * o。 通过推导，得到一个公式T(n) = O(f(n)) t(n)表示代码的执行时间，f(n)表示代码执行次数的总和，所以，第一个例子中的 T(n) = O(2n + 2)和第二个例子的 T(n) = O(2n^2 + 2n + 3)。这就是大 O 时间复杂度表示法，他并不能具体表示代码的真正执行时间，而是表示代码执行时间随数据规模增长的变化趋势。 其中，f(n)中的低阶、常量、系数、三部分对增长趋势不产生绝对影响（在（2n^2 + 2n + 3）中，低阶是 2n、常量是 3、系数是 2），所以都可以省略，我们只需要记录一个最大量级就可以，因此，前两个例子的事件复杂度可以记为T(n) = O(n); T(n) = O(n^2)。 几种常见的时间复杂度 （按数量级排列） 常量阶： O(1) // 只要代码的执行时间不随n的增大而增大，这样代码的时间复杂度都记作O(1) const func = (n) =\u003e { const a = 1; const b = 2; return a + b; }; 对数阶： O(log n) let i = 1; while (i \u003c= n) { i = i * 2; } 线性阶： O(n) 线性对数阶： O(n * log n) 平方阶： O(n^2)、立方阶： O（n^3）…… 指数阶： O(2^n) 阶乘阶： O(n!) 空间复杂度 与时间复杂度同理，表示算法的存储空间与数据规模的增长关系。 常见的空间复杂度 O(1)、O(n)、o(n^2) ","date":"2022-01-03","objectID":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/:3:1","tags":["数据结构与算法","学习笔记"],"title":"数据结构（一）时间复杂度与空间复杂度","uri":"/myblog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%80%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"},{"categories":null,"content":"关于 LoveIt","date":"2019-08-02","objectID":"/myblog/about/","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"  LoveIt 是一个由  Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/myblog/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"特性 ","date":"2019-08-02","objectID":"/myblog/about/:1:0","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持 Plausible Analytics  支持 Yandex Metrica  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 ","date":"2019-08-02","objectID":"/myblog/about/:1:1","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"外观和布局  桌面端/移动端 响应式布局  浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 73 种社交链接  支持多达 24 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook comments 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 utterances 评论系统  支持 giscus 评论系统 ","date":"2019-08-02","objectID":"/myblog/about/:1:2","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightGallery 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $\\KaTeX$ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 cookieconsent 的 Cookie 许可横幅  支持人物标签的 shortcode … ","date":"2019-08-02","objectID":"/myblog/about/:1:3","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 ","date":"2019-08-02","objectID":"/myblog/about/:2:0","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"},{"categories":null,"content":"特别感谢 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css autocomplete Lunr.js algoliasearch lazysizes object-fit-images Twemoji emoji-data lightGallery clipboard.js Sharer.js TypeIt $\\KaTeX$ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/myblog/about/:3:0","tags":null,"title":"关于 LoveIt","uri":"/myblog/about/"}]